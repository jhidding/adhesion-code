<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding" />
  <meta name="dcterms.date" content="2018-11-04" />
  <title>Computing the adhesion model using C++ and CGAL</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!-- Bootstrap 4.5.0 stylesheet -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
  <link rel="stylesheet" href="css/mods.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
<!-- <script data-main="scripts/main" src="js/require.js"></script> -->
  <!-- Load React. -->
  <!-- Note: when deploying, replace "development.js" with "production.min.js". -->
<!--  <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script> -->


</head>
<body class="d-flex flex-column">

<nav id="TOC" class="navbar navbar-dark bg-dark">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a href="#" class="ml-5 mr-auto navbar-brand">Computing the adhesion model using C++ and CGAL<br><span style="font-size: smaller"> 
        by <i>Johan Hidding</i></span></a>
<div class="collapse navbar-collapse" id="navbarSupportedContent">
<ul>
<li><a href="#abstract">Abstract</a>
<ul>
<li><a href="#version">Version</a></li>
</ul></li>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#literate-programming">Literate programming</a></li>
<li><a href="#program-outline">Program outline</a></li>
</ul></li>
<li><a href="#initial-conditions">Initial conditions</a>
<ul>
<li><a href="#creating-the-box">Creating the box</a></li>
<li><a href="#white-noise">White noise</a></li>
<li><a href="#introducing-correlation">Introducing correlation</a></li>
<li><a href="#power-spectrum">Power spectrum</a></li>
<li><a href="#compute-initial-potential">Compute initial potential</a></li>
</ul></li>
<li><a href="#the-adhesion-model">The Adhesion model</a>
<ul>
<li><a href="#theory">Theory</a></li>
<li><a href="#cgal-geometry-kernels">CGAL Geometry kernels</a></li>
<li><a href="#adhesion-header">Adhesion header</a></li>
<li><a href="#computing-the-triangulation">Computing the triangulation</a></li>
<li><a href="#node-properties">Node properties</a></li>
<li><a href="#velocity">Velocity</a></li>
<li><a href="#getting-all-nodes">Getting all nodes</a></li>
<li><a href="#the-power-diagram-1">The power diagram</a></li>
</ul></li>
<li><a href="#the-main-program">The main program</a>
<ul>
<li><a href="#main-loop">Main loop</a></li>
<li><a href="#main-function">Main function</a></li>
</ul></li>
<li><a href="#python-bindings">Python bindings</a></li>
<li><a href="#appendix">Appendix</a>
<ul>
<li><a href="#numerical-integration">Numerical integration</a></li>
<li><a href="#manipulating-meshes">Manipulating meshes</a></li>
<li><a href="#writing-to-disk">Writing to disk</a></li>
<li><a href="#fourier-interface">Fourier interface</a></li>
</ul></li>
<li><a href="#bibliography">References</a></li>
</ul>
</div>
</nav>

<!-- <nav class="navbar navbar-dark navbar-expand-md bg-dark mb-4">
<p class="author">Johan Hidding</p>
<p class="date">November 4, 2018</p>
</nav>
 -->

<main role="main" class="flex-fill"><div class="container my-5">
<p><a href="https://doi.org/10.5281/zenodo.1477536">DOI:10.5281/zenodo.1477535</a></p>
<h1 id="abstract">Abstract</h1>
<p>We present a (relatively) small example of using the CGAL <span class="citation" data-cites="cgal:eb-18b">(The CGAL Project 2018)</span> library to run the adhesion model. This literate C++ code generates an initial potential field and computes the <em>regular triangulation</em> to that potential, which is a weighted generalisation of the <em>Delaunay triangulation</em>. The output is a selection of its dual, the power diagram or weighted Voronoi tessellation, written in a form that is ready for analysis and visualisation.</p>
<p>This software emanates from NWO project 614.000.908 supervised by Gert Vegter and Rien van de Weygaert.</p>
<h2 id="version">Version</h2>
<div class="annotated-code">
<p><span><em>«version»=</em></span></p>
<div class="sourceCode" id="version"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="version-1"><a href="#version-1" aria-hidden="true"></a><span class="pp">#define VERSION </span><span class="st">&quot;1.0&quot;</span></span></code></pre></div>
</div>
<h1 id="introduction">Introduction</h1>
<p>The adhesion model simulates the formation of structure in the Universe on the largest scales. The normal way to do this is to divide matter in the universe into discrete chunks, called particles, and follow their motion and gravitational potential in a lock-step iteration scheme, otherwise known as the N-body simulation.</p>
<p>The adhesion model takes an entirely different approach. It takes as input the initial velocity potential by which particles move, and from that, computes a direct approximation of the geometry of the structures that will form. This geometry is completely specified in terms of voids, walls, filaments and clusters, the structures that together shape the <em>cosmic web</em>. The adhesion model is accurate enough to predict the structures that will form the megaparsec scale of the cosmic web but doesn’t reveal the halo structures that are shown in N-body simulations to form inside these structures.</p>
<p>The code presented here computes the adhesion model using the Computational Geometry Algorithm Library (CGAL). The algorithms implemented in this library represent the state-of-the-art of computational geometry, among which is the algorithm to compute the <em>regular triangulation</em> of a weighted point set <span class="citation" data-cites="cgal:pt-t3-18b cgal:pt-tds3-18b">(Jamin, Pion, and Teillaud 2018b, 2018a)</span>.</p>
<div id="fig:output-example" class="fignos">
<figure>
<img src="figures/web-evolution.png" alt="" /><figcaption><span>Figure 1:</span> Example output of the program, rendered with ParaView. We show the adhesion generated cosmic web using an Eisenstein-Hu CDM power spectrum, showing three time frames for <span class="math inline">\(D_+ = 0.2, 0.4\)</span> and <span class="math inline">\(0.6\)</span>. The axes have units of <span class="math inline">\(h^{-1}\ {\rm Mpc}\)</span>. The top left part of the rendering shows a large expanding void.</figcaption>
</figure>
</div>
<p>This document is aimed to be self-containing. This means that all the code to build a working adhesion model is included. We’ve tried to limit the involvement of too much boilerplate code by using existing libraries where possible. The main body of the code is covered in three sections. We start with generating initial conditions in the Fourier domain. Then we proceed with implementing the adhesion model on the basis of the algorithms and data structures provided by CGAL. We tie things together in a main executable that reads a configuration file and runs the model. The supplementary material contains necessary routines for dealing with Fourier transforms, IO and handling of mesh data.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>From the reader a basic knowledge of programming is required. Familiarity with C/C++ will help to understand the code samples. However, all the code is explained in detail. To run the code the following libraries should be present on the system:</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 12%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Package</th>
<th style="text-align: left;">Version</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">C++ compiler</td>
<td style="text-align: left;">C++17</td>
<td style="text-align: left;">Tested with GCC 8 and LLVM 6.</td>
</tr>
<tr class="even">
<td style="text-align: left;">GNU Make</td>
<td style="text-align: left;">≥4.0</td>
<td style="text-align: left;">Build everything.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CGAL</td>
<td style="text-align: left;">≥4.12</td>
<td style="text-align: left;"><a href="http://cgal.org">The Computational Geometry Algorithm Library</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">FFTW3</td>
<td style="text-align: left;">≥3.3</td>
<td style="text-align: left;"><a href="http://www.fftw.org/">The Fastest Fourier Transform in the West</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">GSL</td>
<td style="text-align: left;">≥2.5</td>
<td style="text-align: left;"><a href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">hdf5-cpp</td>
<td style="text-align: left;">≥1.8.13</td>
<td style="text-align: left;"><a href="https://support.hdfgroup.org/HDF5/doc/cpplus_RM/index.html">HDF5</a> is used to store large blobs of binary data and meta data.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">yaml-cpp</td>
<td style="text-align: left;">≥0.5</td>
<td style="text-align: left;"><a href="https://github.com/jbeder/yaml-cpp">YAML-cpp</a> is a YAML parser for C++. We use it to parse configuration files.</td>
</tr>
<tr class="even">
<td style="text-align: left;">argagg</td>
<td style="text-align: left;">≥0.4.6</td>
<td style="text-align: left;"><a href="https://github.com/vietjtnguyen/argagg">ArgAgg</a> stands for Argument Aggregator and is a C++ command-line argument parser.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">fmt</td>
<td style="text-align: left;">≥4.1</td>
<td style="text-align: left;"><a href="http://fmtlib.net/latest/index.html">fmt</a> is a string formatting library that has a similar interface as Python’s.</td>
</tr>
<tr class="even">
<td style="text-align: left;">TBB</td>
<td style="text-align: left;">≥4.3</td>
<td style="text-align: left;"><a href="https://www.threadingbuildingblocks.org/">Threading Building Blocks</a> is a Intel library for parallel computation in C++. This is an optional dependency. Versions after 4.4 (2016) are numbered after their release date.</td>
</tr>
</tbody>
</table>
<p>Extracting the source code from the Markdown or building the report is done using the Pandoc document converter. Additional requirements are:</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 12%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Package</th>
<th style="text-align: left;">Version</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Pandoc</td>
<td style="text-align: left;">≥2.2.1</td>
<td style="text-align: left;"><a href="http://pandoc.org/">Pandoc</a> is a universal document converter. You’ll need a version with Lua filter support, which was added in Pandoc 2.0.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pandoc-citeproc</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">BibTeX support for Pandoc.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pandoc-eqnos</td>
<td style="text-align: left;">≥1.3.0</td>
<td style="text-align: left;">Number and reference equations. This extension was written in Python, it can be installed using <code>pip install pandoc-eqnos</code>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">pandoc-fignos</td>
<td style="text-align: left;">≥1.3.0</td>
<td style="text-align: left;">Number and reference figures. Another Python extension, install with <code>pip install pandoc-fignos</code>.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">rsvg-convert</td>
<td style="text-align: left;">≥2.40</td>
<td style="text-align: left;">Convert SVG files.</td>
</tr>
</tbody>
</table>
<p>All of these packages are available in the Debian GNU/Linux package repositories. Install instructions are included in the repository at <a href="https://github.com/jhidding/adhesion-code">https://github.com/jhidding/adhesion-code</a>.</p>
<h2 id="literate-programming">Literate programming</h2>
<p>This example is written in a style of <em>literate programming</em> <span class="citation" data-cites="Knuth1984">(Knuth 1984)</span>. This document contains a complete and functioning example of working with CGAL to compute the adhesion model. For didactic reasons we don’t always give the listing of an entire source file in one go. In stead, we use a system of references known as <em>noweb</em> <span class="citation" data-cites="Ramsey1994">(Ramsey 1994)</span>.</p>
<p>Inside source fragments you may encounter a line with <code>&lt;&lt;...&gt;&gt;</code> marks like,</p>
<div class="annotated-code">
<p><span><em>«examples/hello_world.cc»=</em></span></p>
<div class="sourceCode" id="cb1" data-file="examples/hello_world.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>&lt;&lt;example-main-function&gt;&gt;</span></code></pre></div>
</div>
<p>which is then elsewhere specified. Order doesn’t matter,</p>
<div class="annotated-code">
<p><span><em>«hello-world»=</em></span></p>
<div class="sourceCode" id="hello-world"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="hello-world-1"><a href="#hello-world-1" aria-hidden="true"></a><span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span></code></pre></div>
</div>
<p>So we can reference the <code>&lt;&lt;hello-world&gt;&gt;</code> code block later on.</p>
<div class="annotated-code">
<p><span><em>«example-main-function»=</em></span></p>
<div class="sourceCode" id="example-main-function"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="example-main-function-1"><a href="#example-main-function-1" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</span>
<span id="example-main-function-2"><a href="#example-main-function-2" aria-hidden="true"></a>  &lt;&lt;hello-world&gt;&gt;</span>
<span id="example-main-function-3"><a href="#example-main-function-3" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>A definition can be appended with more code as follows (in this case, order does matter!):</p>
<div class="annotated-code">
<p><span><em>«hello-world»+</em></span></p>
<div class="sourceCode" id="hello-world"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="hello-world-1"><a href="#hello-world-1" aria-hidden="true"></a><span class="cf">return</span> EXIT_SUCCESS;</span></code></pre></div>
</div>
<p>These blocks of code can be <em>tangled</em> into source files. The source code presented in this report combine into a fully working example of the adhesion model!</p>
<h2 id="program-outline">Program outline</h2>
<p>The program reads a YAML configuration file and writes output data to HDF5 <span class="citation" data-cites="HDF5">(Folk et al. 2011)</span>. YAML is an extension of the JSON data format aimed at human readability and is supported across many programming languages.</p>
<p>The configuration file contains information about box size, initial conditions, and output specification. We generate initial conditions based on the <span class="math inline">\(\Lambda\)</span>CDM cosmological model in the form of an initial velocity potential <span class="math inline">\(\Phi_0\)</span>. Then we run the CGAL regular triangulation algorithm on those initial conditions for any number of specified time steps. Note that the adhesion model is not an iterative scheme, so each time step is an independent computation.</p>
<p>Information about the nodes, filaments and walls is then extracted from the regular triangulation and stored in the HDF5 file. Additionally, we will create Wavefront OBJ files containing a sample of the generated structures. These files are suitable for display in most scientific visualisation packages. We used ParaView to create the screenshots presented in this report.</p>
<div id="fig:outline" class="fignos">
<figure>
<img src="figures/app-graph.svg" alt="" /><figcaption><span>Figure 2:</span> Outline of the program</figcaption>
</figure>
</div>
<h3 id="configuration">Configuration</h3>
<p>We read the configuration from a YAML file. This file specifies the box size, cosmology and the requested output. For the cosmological parameters we took the latest values from the Planck collaboration <span class="citation" data-cites="Planck2018">(Planck Collaboration et al. 2018)</span>.</p>
<div class="annotated-code">
<p><span><em>«default-config»=</em></span></p>
<div class="sourceCode" id="default-config"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="default-config-1"><a href="#default-config-1" aria-hidden="true"></a><span class="co"># Default configuration</span></span>
<span id="default-config-2"><a href="#default-config-2" aria-hidden="true"></a></span>
<span id="default-config-3"><a href="#default-config-3" aria-hidden="true"></a><span class="fu">box</span><span class="kw">:</span></span>
<span id="default-config-4"><a href="#default-config-4" aria-hidden="true"></a><span class="at">  </span><span class="fu">N</span><span class="kw">:</span><span class="at">      </span><span class="dv">128</span><span class="co">       # logical box size</span></span>
<span id="default-config-5"><a href="#default-config-5" aria-hidden="true"></a><span class="at">  </span><span class="fu">L</span><span class="kw">:</span><span class="at">       </span><span class="fl">50.0</span><span class="co">     # physical box size</span></span>
<span id="default-config-6"><a href="#default-config-6" aria-hidden="true"></a></span>
<span id="default-config-7"><a href="#default-config-7" aria-hidden="true"></a><span class="fu">cosmology</span><span class="kw">:</span></span>
<span id="default-config-8"><a href="#default-config-8" aria-hidden="true"></a><span class="at">  </span><span class="fu">power-spectrum</span><span class="kw">:</span><span class="at"> Eisenstein &amp; Hu (no baryons)</span></span>
<span id="default-config-9"><a href="#default-config-9" aria-hidden="true"></a><span class="at">  </span><span class="fu">h</span><span class="kw">:</span><span class="at">        </span><span class="fl">0.674</span><span class="co">   # Hubble parameter / 100</span></span>
<span id="default-config-10"><a href="#default-config-10" aria-hidden="true"></a><span class="at">  </span><span class="fu">ns</span><span class="kw">:</span><span class="at">       </span><span class="fl">0.965</span><span class="co">   # primordial power spectrum index</span></span>
<span id="default-config-11"><a href="#default-config-11" aria-hidden="true"></a><span class="at">  </span><span class="fu">Omega0</span><span class="kw">:</span><span class="at">   </span><span class="fl">1.0</span><span class="co">     # density in units of critical density</span></span>
<span id="default-config-12"><a href="#default-config-12" aria-hidden="true"></a><span class="at">  </span><span class="fu">sigma8</span><span class="kw">:</span><span class="at">   </span><span class="fl">0.811</span><span class="co">   # amplitude over 8 Mpc/h</span></span>
<span id="default-config-13"><a href="#default-config-13" aria-hidden="true"></a></span>
<span id="default-config-14"><a href="#default-config-14" aria-hidden="true"></a><span class="fu">run</span><span class="kw">:</span></span>
<span id="default-config-15"><a href="#default-config-15" aria-hidden="true"></a><span class="at">  </span><span class="fu">seed</span><span class="kw">:</span><span class="at">     </span><span class="dv">8</span></span>
<span id="default-config-16"><a href="#default-config-16" aria-hidden="true"></a><span class="at">  </span><span class="fu">time</span><span class="kw">:</span><span class="at">     </span><span class="kw">[</span><span class="fl">0.2</span><span class="kw">,</span><span class="at"> </span><span class="fl">0.5</span><span class="kw">,</span><span class="at"> </span><span class="fl">1.0</span><span class="kw">]</span></span>
<span id="default-config-17"><a href="#default-config-17" aria-hidden="true"></a></span>
<span id="default-config-18"><a href="#default-config-18" aria-hidden="true"></a><span class="fu">output</span><span class="kw">:</span></span>
<span id="default-config-19"><a href="#default-config-19" aria-hidden="true"></a><span class="at">  </span><span class="fu">hdf5</span><span class="kw">:</span><span class="at">            output/lcdm.h5</span></span>
<span id="default-config-20"><a href="#default-config-20" aria-hidden="true"></a><span class="at">  </span><span class="fu">walls</span><span class="kw">:</span><span class="at">           output/lcdm-{time:02.1f}-walls.obj</span></span>
<span id="default-config-21"><a href="#default-config-21" aria-hidden="true"></a><span class="at">  </span><span class="fu">filaments</span><span class="kw">:</span><span class="at">       output/lcdm-{time:02.1f}-filaments.obj</span></span>
<span id="default-config-22"><a href="#default-config-22" aria-hidden="true"></a><span class="at">  </span><span class="fu">threshold</span><span class="kw">:</span><span class="at">       </span><span class="fl">1.0</span></span></code></pre></div>
</div>
<p>In the output specification we inserted some syntax for formatting the output filename based on the time step. The <code>{time:02.1f}</code> part in the output filenames for walls and filaments will be replaced with the <code>time</code> parameter of the run. The precise syntax of these format expressions is specified in <a href="http://fmtlib.net/dev/syntax.html">the documentation of the <code>fmt</code> library</a>.</p>
<p>The <code>threshold</code> parameter is the square of the length at which we consider an edge to span a collapsed structure. In a triangulated grid edges can have a length of <span class="math inline">\(\sqrt{3} l_p\)</span>, where <span class="math inline">\(l_p\)</span> is the resolution of the box <span class="math inline">\(l_p = L/N\)</span>. This means that the threshold should be set higher than <span class="math inline">\(3 L^2/N^2\)</span>. In this case, with <span class="math inline">\(L = 50.0 h^{-1} {\rm Mpc}\)</span> and <span class="math inline">\(N = 128\)</span>, a threshold length of <span class="math inline">\(1.0\)</span> is a safe choice.</p>
<h3 id="command-line-arguments">Command line arguments</h3>
<p>The main program has only few arguments. It reads configuration from a specified input file. We include the above configuration as a fallback if no arguments are given.</p>
<div class="annotated-code">
<p><span><em>«main-arguments»=</em></span></p>
<div class="sourceCode" id="main-arguments"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="main-arguments-1"><a href="#main-arguments-1" aria-hidden="true"></a>argagg::parser argparser {{</span>
<span id="main-arguments-2"><a href="#main-arguments-2" aria-hidden="true"></a>  { <span class="st">&quot;help&quot;</span>,    {<span class="st">&quot;-h&quot;</span>, <span class="st">&quot;--help&quot;</span>},</span>
<span id="main-arguments-3"><a href="#main-arguments-3" aria-hidden="true"></a>    <span class="st">&quot;Show this help message.&quot;</span>, <span class="dv">0</span> },</span>
<span id="main-arguments-4"><a href="#main-arguments-4" aria-hidden="true"></a>  { <span class="st">&quot;version&quot;</span>, {<span class="st">&quot;--version&quot;</span>},</span>
<span id="main-arguments-5"><a href="#main-arguments-5" aria-hidden="true"></a>    <span class="st">&quot;Show the software version.&quot;</span>, <span class="dv">0</span> },</span>
<span id="main-arguments-6"><a href="#main-arguments-6" aria-hidden="true"></a>  { <span class="st">&quot;config&quot;</span>,  {<span class="st">&quot;-c&quot;</span>, <span class="st">&quot;--config&quot;</span>},</span>
<span id="main-arguments-7"><a href="#main-arguments-7" aria-hidden="true"></a>    <span class="st">&quot;Supply configuration file.&quot;</span>, <span class="dv">1</span> },</span>
<span id="main-arguments-8"><a href="#main-arguments-8" aria-hidden="true"></a>  { <span class="st">&quot;defaults&quot;</span>, {<span class="st">&quot;-d&quot;</span>, <span class="st">&quot;--defaults&quot;</span>},</span>
<span id="main-arguments-9"><a href="#main-arguments-9" aria-hidden="true"></a>    <span class="st">&quot;Show default configuration.&quot;</span>, <span class="dv">0</span> }</span>
<span id="main-arguments-10"><a href="#main-arguments-10" aria-hidden="true"></a>}};</span></code></pre></div>
</div>
<p>The <code>ArgAgg</code> library parses command-line arguments and composes the following help message when the user passes the <code>--help</code> flag:</p>
<pre><code>Adhesion model example code -- (C) 2018 Johan Hidding
    -h, --help
        Show this help message.
    --version
        Show the software version.
    -c, --config
        Supply configuration file.
    -d, --defaults
        Show default configuration.</code></pre>
<h3 id="output">Output</h3>
<p>We write output to two kinds of files: HDF5 (Hierarchical Data Format) and Wavefront OBJ.</p>
<h4 id="hdf5">HDF5</h4>
<p>HDF5 files have a hierarchy similar to a filesystem with groups and data spaces. Each item in the hierarchy can have meta-data attributes. HDF5 files can be read (and written) in all widely used data analysis frameworks, i.e. Python, GNU R, Julia or even Matlab if you’re so inclined. As an example, we show the adhesion cluster mass function in Figure <a href="#fig:mass-function">3</a>.</p>
<div id="fig:mass-function" class="fignos">
<figure>
<img src="figures/mass-functions.svg" alt="" /><figcaption><span>Figure 3:</span> Cluster mass function. We took all nodes that identify as clusters and plot the distribution of the logarithm of their mass, that is, the number of objects per <span class="math inline">\(h^{-3}{\rm Mpc}^3\)</span> per logarithmic bin <span class="math inline">\(\Delta \log M/M^*\)</span> where <span class="math inline">\(M^*\)</span> is <span class="math inline">\(\rho_u h^{-3}{\rm Mpc}^3\)</span>. Both plots show the same data, but the right panel uses a logarithmic y-axis. The solid lines show a fit with a log-normal distribution. Note that we see an increase in the number of objects at intermediate redshift, which then get merged into more massive clusters at later times.</figcaption>
</figure>
</div>
<h4 id="wavefront-obj">Wavefront OBJ</h4>
<p>Wavefront OBJ format is a text based format designed for computer graphics applications. We chose it for two reasons. It is relatively easy to write and it has support for per-face texture coordinates. Normally these coordinates are used to map texture images onto the three dimensional surface. We abuse the texture coordinates to represent the wall density. This method of encoding extra information is supported by ParaView, by which we rendered Figure <a href="#fig:output-example">1</a>.</p>
<h1 id="initial-conditions">Initial conditions</h1>
<p>We will generate an initial potential <span class="math inline">\(\Phi_0\)</span>, sampled on a cubic mesh with a logical size of <span class="math inline">\(N\)</span> pixels on each side and a physical size <span class="math inline">\(L\)</span> in units of <span class="math inline">\(h^{-1}{\rm Mpc}\)</span>. The corresponding initial density field will follow a CDM (without baryons) power spectrum, as given by <span class="citation" data-cites="Eisenstein1999">Eisenstein and Hu (1999)</span>.</p>
<p>We’ll have box parameters (<span class="math inline">\(N\)</span>, <span class="math inline">\(L\)</span> and derived quantities) stored in a <code>BoxParam</code> object that is defined in <code>boxparam.hh</code>. Given the box parameters and input cosmology, we have three steps in generating the initial conditions:</p>
<ul>
<li>Generate white noise</li>
<li>Normalise power spectrum</li>
<li>Compute potential</li>
</ul>
<p>The interface to these steps is collected in <code>initial_conditions.hh</code>.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions.hh»=</em></span></p>
<div class="sourceCode" id="cb3" data-file="src/initial_conditions.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;boxparam.hh&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;yaml-cpp/yaml.h&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="kw">using</span> PowerSpectrum = <span class="bu">std::</span>function&lt;<span class="dt">double</span> (<span class="dt">double</span>)&gt;;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="kw">using</span> Config = YAML::Node;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="at">extern</span> <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>generate_white_noise(</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> seed);</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a><span class="at">extern</span> PowerSpectrum EisensteinHu(</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>    Config <span class="at">const</span> &amp;cosmology);</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="at">extern</span> PowerSpectrum normalize_power_spectrum(</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>    PowerSpectrum <span class="at">const</span> &amp;P,</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    Config <span class="at">const</span> &amp;cosmology);</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a><span class="at">extern</span> <span class="dt">void</span> compute_potential(</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &amp;white_noise,</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>    PowerSpectrum <span class="at">const</span> &amp;P);</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a><span class="at">extern</span> <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>generate_initial_potential(</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>    Config <span class="at">const</span> &amp;config);</span></code></pre></div>
</div>
<p>The <code>generate_initial_potential</code> function collects all three steps.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions/generate.cc»=</em></span></p>
<div class="sourceCode" id="cb4" data-file="src/initial_conditions/generate.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; generate_initial_potential(</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    Config <span class="at">const</span> &amp;config)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>{</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;# Generating white noise with seed:</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>            &lt;&lt; config[<span class="st">&quot;run&quot;</span>][<span class="st">&quot;seed&quot;</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="kw">auto</span> seed = config[<span class="st">&quot;run&quot;</span>][<span class="st">&quot;seed&quot;</span>].as&lt;<span class="dt">unsigned</span> <span class="dt">long</span>&gt;();</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>  <span class="kw">auto</span> field = generate_white_noise(box, seed);</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;Applying power spectrum with cosmology:</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>            &lt;&lt; config[<span class="st">&quot;cosmology&quot;</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  <span class="kw">auto</span> cosmology = config[<span class="st">&quot;cosmology&quot;</span>];</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  <span class="kw">auto</span> power_spectrum = normalize_power_spectrum(</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    box, EisensteinHu(cosmology), cosmology);</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>  compute_potential(box, field, power_spectrum);</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a>  <span class="cf">return</span> field;</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>We will first define the <code>BoxParam</code> class, then work on the implementation of the rest of the functions declared in <code>initial_conditions.hh</code>.</p>
<h2 id="creating-the-box">Creating the box</h2>
<p>The logical and physical box sizes, <span class="math inline">\(N\)</span> and <span class="math inline">\(L\)</span>, are needed in all of our computations. These parameters are collected into an instance of <code>BoxParam</code>, which has several methods that support working with coordinates in the box both in real and frequency space.</p>
<div class="annotated-code">
<p><span><em>«src/boxparam.hh»=</em></span></p>
<div class="sourceCode" id="cb5" data-file="src/boxparam.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>&lt;&lt;helper-functions&gt;&gt;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>&lt;&lt;increment-index&gt;&gt;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="kw">class</span> BoxParam {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>  <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">unsigned</span> R = <span class="dv">3</span>; <span class="co">// dimension of the box</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>  <span class="dt">unsigned</span> N;         <span class="co">// number of grid points in a row</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>  <span class="dt">double</span>   L;         <span class="co">// physical size of the box</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>  BoxParam(<span class="dt">unsigned</span> N_, <span class="dt">double</span> L_)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>    : N(N_)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>    , L(L_)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>  {}</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>  &lt;&lt;fourier-properties&gt;&gt;</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>  &lt;&lt;boxparam-methods&gt;&gt;</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h3 id="methods">Methods</h3>
<p>Some essential helper functions we’ll need are the <code>shape</code> and <code>size</code> of the box.</p>
<div class="annotated-code">
<p><span><em>«boxparam-methods»=</em></span></p>
<div class="sourceCode" id="boxparam-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="boxparam-methods-1"><a href="#boxparam-methods-1" aria-hidden="true"></a><span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt; shape() <span class="at">const</span> {</span>
<span id="boxparam-methods-2"><a href="#boxparam-methods-2" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt;({ N, N, N });</span>
<span id="boxparam-methods-3"><a href="#boxparam-methods-3" aria-hidden="true"></a>}</span>
<span id="boxparam-methods-4"><a href="#boxparam-methods-4" aria-hidden="true"></a></span>
<span id="boxparam-methods-5"><a href="#boxparam-methods-5" aria-hidden="true"></a><span class="dt">size_t</span> size() <span class="at">const</span> {</span>
<span id="boxparam-methods-6"><a href="#boxparam-methods-6" aria-hidden="true"></a>  <span class="cf">return</span> N * N * N;</span>
<span id="boxparam-methods-7"><a href="#boxparam-methods-7" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>We add a method to compute the <span class="math inline">\(n\)</span>-th point on a grid. First we need to know the integer position along each axis for a given linear index.</p>
<div class="annotated-code">
<p><span><em>«boxparam-methods»+</em></span></p>
<div class="sourceCode" id="boxparam-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="boxparam-methods-1"><a href="#boxparam-methods-1" aria-hidden="true"></a><span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt; iloc(<span class="dt">size_t</span> i) <span class="at">const</span> {</span>
<span id="boxparam-methods-2"><a href="#boxparam-methods-2" aria-hidden="true"></a>  <span class="dt">size_t</span> x = i % N,</span>
<span id="boxparam-methods-3"><a href="#boxparam-methods-3" aria-hidden="true"></a>         y = (i / N) % N,</span>
<span id="boxparam-methods-4"><a href="#boxparam-methods-4" aria-hidden="true"></a>         z = i / (N * N);</span>
<span id="boxparam-methods-5"><a href="#boxparam-methods-5" aria-hidden="true"></a></span>
<span id="boxparam-methods-6"><a href="#boxparam-methods-6" aria-hidden="true"></a>  <span class="cf">return</span> {z, y, x};</span>
<span id="boxparam-methods-7"><a href="#boxparam-methods-7" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Note that we set the <span class="math inline">\(x\)</span>-coordinate to be the fastest changing coordinate in the flattened array. This is known as <em>row-major</em> ordering, which the same as how indexing into C/C++ and Python/NumPy arrays works. This also means that when we use a <code>std::array&lt;size_t,3&gt;</code> as a 3-dimensional index into an array, the axes are reversed, so <code>{z, y, x}</code>.</p>
<p>Then we can compute the physical point by multiplying the integer position with the resolution of the box. This method accepts a template argument for the type of the <code>Point</code>. We’ll assume <code>Point</code> has a constructor that accepts the <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> coordinates as arguments.</p>
<div class="annotated-code">
<p><span><em>«boxparam-methods»+</em></span></p>
<div class="sourceCode" id="boxparam-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="boxparam-methods-1"><a href="#boxparam-methods-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="boxparam-methods-2"><a href="#boxparam-methods-2" aria-hidden="true"></a>Point point(<span class="dt">size_t</span> i) <span class="at">const</span> {</span>
<span id="boxparam-methods-3"><a href="#boxparam-methods-3" aria-hidden="true"></a>  <span class="kw">auto</span> p = iloc(i);</span>
<span id="boxparam-methods-4"><a href="#boxparam-methods-4" aria-hidden="true"></a>  <span class="cf">return</span> Point(p[<span class="dv">2</span>] * L/N, p[<span class="dv">1</span>] * L/N, p[<span class="dv">0</span>] * L/N);</span>
<span id="boxparam-methods-5"><a href="#boxparam-methods-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="iterating-multi-dimensional-arrays">Iterating multi-dimensional arrays</h4>
<p>We’ll be indexing multi-dimensional arrays. To prevent having to write nested for-loops, we use the <code>increment_index</code> helper function. This increments the last index first, if it caries, set it back to zero and increment the next to last index and so on.</p>
<div class="annotated-code">
<p><span><em>«increment-index»=</em></span></p>
<div class="sourceCode" id="increment-index"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="increment-index-1"><a href="#increment-index-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="dt">unsigned</span> R&gt;</span>
<span id="increment-index-2"><a href="#increment-index-2" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">unsigned</span> increment_index(</span>
<span id="increment-index-3"><a href="#increment-index-3" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, R&gt; <span class="at">const</span> &amp;shape,</span>
<span id="increment-index-4"><a href="#increment-index-4" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, R&gt; &amp;index)</span>
<span id="increment-index-5"><a href="#increment-index-5" aria-hidden="true"></a>{</span>
<span id="increment-index-6"><a href="#increment-index-6" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; R; ++i) {</span>
<span id="increment-index-7"><a href="#increment-index-7" aria-hidden="true"></a>    <span class="dt">unsigned</span> k = R - i - <span class="dv">1</span>;</span>
<span id="increment-index-8"><a href="#increment-index-8" aria-hidden="true"></a>    <span class="cf">if</span> (++index[k] &lt; shape[k])</span>
<span id="increment-index-9"><a href="#increment-index-9" aria-hidden="true"></a>      <span class="cf">return</span> k;</span>
<span id="increment-index-10"><a href="#increment-index-10" aria-hidden="true"></a></span>
<span id="increment-index-11"><a href="#increment-index-11" aria-hidden="true"></a>    index[k] = <span class="dv">0</span>;</span>
<span id="increment-index-12"><a href="#increment-index-12" aria-hidden="true"></a>  }</span>
<span id="increment-index-13"><a href="#increment-index-13" aria-hidden="true"></a></span>
<span id="increment-index-14"><a href="#increment-index-14" aria-hidden="true"></a>  <span class="cf">return</span> R;</span>
<span id="increment-index-15"><a href="#increment-index-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="helper-functions">Helper functions</h4>
<p>The <code>sqr</code> function computes the square of any object that has the multiplication operator defined.</p>
<div class="annotated-code">
<p><span><em>«helper-functions»=</em></span></p>
<div class="sourceCode" id="helper-functions"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="helper-functions-1"><a href="#helper-functions-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="helper-functions-2"><a href="#helper-functions-2" aria-hidden="true"></a><span class="kw">inline</span> T sqr(T x) { <span class="cf">return</span> x*x; }</span></code></pre></div>
</div>
<h3 id="fourier-properties">Fourier properties</h3>
<p>These functions we’ll need when we compute Fourier transforms. The real FFT algorithm saves precious memory by using only half the space of the complex FFT. With the exception of the Nyquist frequencies that makes <span class="math inline">\(N/2 + 1\)</span> for the <span class="math inline">\(x\)</span>-axis.</p>
<div class="annotated-code">
<p><span><em>«fourier-properties»=</em></span></p>
<div class="sourceCode" id="fourier-properties" data-append="true"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="fourier-properties-1"><a href="#fourier-properties-1" aria-hidden="true"></a><span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt; rfft_shape() <span class="at">const</span> {</span>
<span id="fourier-properties-2"><a href="#fourier-properties-2" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt;{ N, N, N/<span class="dv">2</span> + <span class="dv">1</span> };</span>
<span id="fourier-properties-3"><a href="#fourier-properties-3" aria-hidden="true"></a>}</span>
<span id="fourier-properties-4"><a href="#fourier-properties-4" aria-hidden="true"></a></span>
<span id="fourier-properties-5"><a href="#fourier-properties-5" aria-hidden="true"></a><span class="dt">size_t</span> rfft_size() <span class="at">const</span> {</span>
<span id="fourier-properties-6"><a href="#fourier-properties-6" aria-hidden="true"></a>  <span class="cf">return</span> N * N * (N / <span class="dv">2</span> + <span class="dv">1</span>);</span>
<span id="fourier-properties-7"><a href="#fourier-properties-7" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Next up, we need to compute the wave number of the Fourier mode represented at a certain index. With a physical box-size of <span class="math inline">\(L\)</span> and a logical size of <span class="math inline">\(N\)</span>, we use the following convention</p>
<p><span class="math display">\[k_i = i \frac{2 \pi}{L},~{\rm for}~i \in [0, 1, \dots, N/2, -N/2 - 1, \dots, -1].\]</span></p>
<div class="annotated-code">
<p><span><em>«fourier-properties»+</em></span></p>
<div class="sourceCode" id="fourier-properties" data-append="true"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="fourier-properties-1"><a href="#fourier-properties-1" aria-hidden="true"></a><span class="dt">double</span> wave_number(<span class="dt">int</span> i) <span class="at">const</span> {</span>
<span id="fourier-properties-2"><a href="#fourier-properties-2" aria-hidden="true"></a>  <span class="cf">return</span> ( <span class="dt">int</span>(i) &gt; <span class="dt">int</span>(N)/<span class="dv">2</span></span>
<span id="fourier-properties-3"><a href="#fourier-properties-3" aria-hidden="true"></a>         ? <span class="dt">int</span>(i) - <span class="dt">int</span>(N)</span>
<span id="fourier-properties-4"><a href="#fourier-properties-4" aria-hidden="true"></a>         : <span class="dt">int</span>(i) ) * (<span class="dv">2</span>*M_PI)/L;</span>
<span id="fourier-properties-5"><a href="#fourier-properties-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>When we compute the power spectrum and the likes, we need the absolute value of <span class="math inline">\(\vec{k}\)</span>.</p>
<div class="annotated-code">
<p><span><em>«fourier-properties»+</em></span></p>
<div class="sourceCode" id="fourier-properties" data-append="true"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="fourier-properties-1"><a href="#fourier-properties-1" aria-hidden="true"></a><span class="dt">double</span> k_abs(<span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt; <span class="at">const</span> &amp;loc) <span class="at">const</span> {</span>
<span id="fourier-properties-2"><a href="#fourier-properties-2" aria-hidden="true"></a>  <span class="dt">double</span> x = <span class="fl">0.0</span>;</span>
<span id="fourier-properties-3"><a href="#fourier-properties-3" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">size_t</span> i : loc)</span>
<span id="fourier-properties-4"><a href="#fourier-properties-4" aria-hidden="true"></a>    x += sqr(wave_number(i));</span>
<span id="fourier-properties-5"><a href="#fourier-properties-5" aria-hidden="true"></a>  <span class="cf">return</span> sqrt(x);</span>
<span id="fourier-properties-6"><a href="#fourier-properties-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="white-noise">White noise</h2>
<p>Having defined a <code>box</code> we need to fill it with initial density fluctuations. We first generate <em>white noise</em> in real space, then apply the power spectrum by method of <em>Fourier convolution</em>.</p>
<p>The initial conditions are randomly generated on a grid. We suppose a platonic ideal Gaussian random field that underlies our realisation. This is a function that is only defined in probabilistic terms. In cosmology it comes natural that these probabilities do not depend on location. For example, in the case of completely uncorrelated Gaussian white noise, we can ask: what is the probability that this function attains a certain value,</p>
<p><span id="eq:normal-distribution" class="eqnos"><span class="math display">\[P(f(x) = y) = \frac{1}{\sqrt{2\pi \sigma^2}} \exp \left(-\frac{(y - \mu)^2}{2 \sigma^2}\right).\]</span><span class="eqnos-number">(1)</span></span> </p>
<p>A function following only this distribution, without any correlation between points, is also referred to as <em>white noise</em>. We’re looking at quantities, like the density perturbation, that have mean <span class="math inline">\(\mu = 0\)</span>. When we generate white noise, we’re sampling a realisation of such a function <span class="math inline">\(f\)</span> at a limited set of points. This should be considered in contrast with seeing a realisation as as integral quantities to a grid cell. Any integral of a white noise over a finite area results exactly in the mean value.</p>
<p>The <code>white_noise</code> function fills a newly created array with random values, following a normal distribution with <span class="math inline">\(\sigma = 1\)</span>.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions/white_noise.cc»=</em></span></p>
<div class="sourceCode" id="cb6" data-file="src/initial_conditions/white_noise.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>generate_white_noise(</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box, <span class="dt">unsigned</span> <span class="dt">long</span> seed)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>{</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  <span class="kw">auto</span> result = <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;(box.size());</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span class="bu">std::</span>mt19937 random(seed);</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>  <span class="bu">std::</span>normal_distribution&lt;<span class="dt">double</span>&gt; normal;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">double</span> &amp;value : result) {</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>    value = normal(random);</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>  }</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  <span class="cf">return</span> result;</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="introducing-correlation">Introducing correlation</h2>
<p>To get an instance of a physically meaningful field, with non-zero integrals, requires that the values of the function <span class="math inline">\(f\)</span> are positively correlated at the small scale. Taking any two positions <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span>, their correlation is</p>
<p><span class="math display">\[\xi(x_1, x_2) = \langle f(x_1) f(x_2) \rangle.\]</span></p>
<p>Often we write the correlation function <span class="math inline">\(\xi(r)\)</span> because our fields are isotropic and homogeneous. We can now ask the next question: what is the probability that the function <span class="math inline">\(f\)</span> at position <span class="math inline">\(\vec{x}\)</span> attains the value <span class="math inline">\(f(\vec{x}) = y_1\)</span> and at position <span class="math inline">\(\vec{x} + \vec{r}\)</span> attains the value <span class="math inline">\(f(\vec{x} + \vec{r}) = y_2\)</span>,</p>
<p><span id="eq:two-point-function" class="eqnos"><span class="math display">\[P(f(\vec{x}) = y_1, f(\vec{x} + \vec{r}) = y_2) = \frac{1}{\sqrt{2\pi |\Sigma(r)|}} \exp \left(-\frac{1}{2} \begin{pmatrix}y_1\\y_2\end{pmatrix}^T \Sigma^{-1}(r) \begin{pmatrix}y_1\\y_2\end{pmatrix}\right).\]</span><span class="eqnos-number">(2)</span></span> </p>
<p>Here, <span class="math inline">\(\Sigma(r)\)</span> is the correlation matrix,</p>
<p><span class="math display">\[\Sigma(r) = \begin{pmatrix}\sigma^2 &amp; \xi(r)\\\xi(r) &amp; \sigma^2\end{pmatrix},\]</span></p>
<p>Equation <a href="#eq:two-point-function">2</a> (also known as the two-point distribution) can be generalised to a distribution of <span class="math inline">\(N\)</span> variates, the <em>multi-variate normal distribution</em>. It can be shown that, in the case of a statistically homogeneous and isotropic random field, this distribution can always be reduced to the two-point distribution. In that case we refer to the random field as a Gaussian random field.</p>
<div id="fig:colours-of-noise" class="fignos">
<figure>
<img src="figures/noise.svg" alt="" /><figcaption><span>Figure 4:</span> The colours of noise. From left to right we change the power spectrum from <span class="math inline">\(k^0\)</span>, to <span class="math inline">\(k^{-1}\)</span>, to <span class="math inline">\(k^{-2}\)</span>. The red noise can also be obtained by integrating a white noise signal. Red noise is an elemental example of a Markov process, as each value is computed from a state (the cumulative sum) and a random variate (the white noise).</figcaption>
</figure>
</div>
<h2 id="power-spectrum">Power spectrum</h2>
<p>In Figure <a href="#fig:colours-of-noise">4</a> we show three instances of a Gaussian random field with three different correlation functions. In stead of talking about a correlation function, we often use its Fourier transform, the <em>power spectrum</em> to specify the correlation in the random field,</p>
<p><span class="math display">\[\xi(\vec{r}) = \int \mathcal{P}(k) e^{i\vec{k}\cdot\vec{r}} \frac{{\rm d}^3 \vec{k}}{(2\pi)^3}.\]</span></p>
<p>We will now define the Eisenstein-Hu power spectrum and give a method to normalise the amplitudes to match the real Universe.</p>
<h3 id="eisenstein-hu-power-spectrum">Eisenstein-Hu power spectrum</h3>
<p>The power spectrum for CDM is given by an almost scale-free spectrum modified by a <em>transfer function</em> <span class="math inline">\(T_0\)</span> which embodies post-inflation physics.</p>
<p><span class="math display">\[P(k) = A k^{n_s} T_0^2(k)\]</span></p>
<p>To compute <span class="math inline">\(T_0\)</span> from the Boltzmann equation there exists a code called CMBfast, but most often people use a fitting function. Eisenstein &amp; Hu (1997) give the following fitting formula for the CDM transfer function:</p>
<p><span class="math display">\[\begin{aligned}
T_0(q) &amp;=&amp; \frac{L_0}{L_0 + C_0 q^2}\\
L_0(q) &amp;=&amp; \log(2 e + 1.8 q)\\
C_0(q) &amp;=&amp; 14.2 + \frac{731}{1 + 62.5 q},
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(q\)</span> is the wave number re-scaled to find the <em>knee</em> in the CDM power spectrum.</p>
<p><span class="math display">\[q = \frac{k}{h {\rm Mpc}^{-1}} \Theta_{2.7}^2 / \Gamma,\]</span></p>
<p>where <span class="math inline">\(\Theta_{2.7}\)</span> is the temperature of the CMB divided by 2.7 and <span class="math inline">\(\Gamma = \Omega_0 h\)</span>.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions/eisenstein-hu.cc»=</em></span></p>
<div class="sourceCode" id="cb7" data-file="src/initial_conditions/eisenstein-hu.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>PowerSpectrum EisensteinHu(Config <span class="at">const</span> &amp;cosmology)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>{</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="dt">double</span> <span class="at">const</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>    e         = exp(<span class="dv">1</span>),</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>    Theta_CMB = <span class="fl">2.7255</span>/<span class="fl">2.7</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    Omega0    = cosmology[<span class="st">&quot;Omega0&quot;</span>].as&lt;<span class="dt">double</span>&gt;(),</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    h         = cosmology[<span class="st">&quot;h&quot;</span>].as&lt;<span class="dt">double</span>&gt;(),</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    ns        = cosmology[<span class="st">&quot;ns&quot;</span>].as&lt;<span class="dt">double</span>&gt;();</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>  <span class="cf">return</span> [=] (<span class="dt">double</span> k)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>  {</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>    <span class="dt">double</span> q  = k * pow(Theta_CMB, <span class="dv">2</span>)/(Omega0 * h),</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>           L0 = log(<span class="dv">2</span>*e + <span class="fl">1.8</span>*q),</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>           C0 = <span class="fl">14.2</span> + <span class="fl">731.0</span>/(<span class="dv">1</span> + <span class="fl">62.5</span>*q),</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>           T0 = L0 / (L0 + C0 * pow(q, <span class="dv">2</span>));</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    <span class="cf">return</span> pow(k, ns) * pow(T0, <span class="dv">2</span>);</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>  };</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div id="fig:cdm-power-spectrum" class="fignos">
<figure>
<img src="figures/power-spectrum.svg" alt="" /><figcaption><span>Figure 5:</span> The CDM power-spectrum (without baryons).</figcaption>
</figure>
</div>
<h3 id="normalisation">Normalisation</h3>
<p>The power-spectrum needs to be normalised so that the amplitudes of the density perturbations match those in the observed Universe. The chosen scaling is applied using a spherical top-hat filter of radius <span class="math inline">\(8\ h^{-1}{\rm Mpc}\)</span>. The latest measurements from <span class="citation" data-cites="Planck2018">Planck Collaboration et al. (2018)</span> give <span class="math inline">\(\sigma_8 = 0.811 \pm 0.006\)</span> of density perturbations linearly extrapolated to current epoch.</p>
<p>Now, given a density field <span class="math inline">\(f\)</span> we may filter this field with a spherical top-hat function with radius of <span class="math inline">\(8\ h^{-1}{\rm Mpc}\)</span> by means of a convolution <span class="math inline">\(f_R = f \ast W_{\rm th}\)</span>. Then <span class="math inline">\(\sigma_8^2 \equiv \langle f_8^{\star}f_8 \rangle\)</span> can be expressed in Fourier space as <span class="math display">\[\sigma_R^2 = \int \mathcal{P}(\vec{k}) \hat{W}_{\rm th}^2(\vec{k}) \frac{{\rm d}^3 \vec{k}}{{(2\pi)}^3}.\]</span> Because all terms in the integral only depend on <span class="math inline">\(|\vec{k}|\)</span>, we may rewrite this as <span id="eq:normalisation" class="eqnos"><span class="math display">\[\sigma_R^2 = \int_0^{\infty} \mathcal{P}(k)\ \hat{W}_{\rm th}^2(k R)\ k^2 \frac{{\rm d} k}{2 \pi^2}.\]</span><span class="eqnos-number">(3)</span></span>  The integrand in Equation <a href="#eq:normalisation">3</a> can be defined as the following lambda expression:</p>
<div class="annotated-code">
<p><span><em>«define-integrand»=</em></span></p>
<div class="sourceCode" id="define-integrand"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="define-integrand-1"><a href="#define-integrand-1" aria-hidden="true"></a><span class="kw">auto</span> integrand = [&amp;] (<span class="dt">double</span> k) {</span>
<span id="define-integrand-2"><a href="#define-integrand-2" aria-hidden="true"></a>  <span class="cf">return</span> P(k) / (<span class="dv">2</span> * M_PI*M_PI) * pow(W_th(<span class="fl">8.0</span> * k) * k, <span class="dv">2</span>);</span>
<span id="define-integrand-3"><a href="#define-integrand-3" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<p>The Fourier transform of the top-hat window function is given by <span class="math display">\[\hat{W}_{th}(y) = \frac{3}{y^3}\left(\sin y - y \cos y\right).\]</span></p>
<div class="annotated-code">
<p><span><em>«top-hat-function»=</em></span></p>
<div class="sourceCode" id="top-hat-function"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="top-hat-function-1"><a href="#top-hat-function-1" aria-hidden="true"></a><span class="dt">double</span> W_th(<span class="dt">double</span> y) {</span>
<span id="top-hat-function-2"><a href="#top-hat-function-2" aria-hidden="true"></a>  <span class="cf">return</span> <span class="fl">3.0</span> / pow(y, <span class="dv">3</span>) * (sin(y) - y * cos(y));</span>
<span id="top-hat-function-3"><a href="#top-hat-function-3" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>There’s a lot to say about how to normalise initial conditions properly, retaining the statistical properties of a larger ensemble and reducing excess shot noise from having a limited resolution <span class="citation" data-cites="Sirko2005">(see e.g. Sirko 2005)</span>. In practice, good results are obtained by normalising using a numerical integration of Equation <a href="#eq:normalisation">3</a> from <span class="math inline">\(2 \pi / L\)</span> to infinity, compensating for the power lost in the modes exceeding the box size. In particular we would like to fix the typical collapse times of structures of a certain size to be independent of resolution or box size.</p>
<p>The <code>normalize_power_spectrum</code> function computes the integral in Equation <a href="#eq:normalisation">3</a> using the Gauss-Konrod quadrature algorithm for integrals over a semi-infinite domain that is present in the GNU Scientific Library <span class="citation" data-cites="Galassi2002">(Galassi et al. 2002)</span>. It then returns a new function of type <code>PowerSpectrum</code>.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions/normalize_power_spectrum.cc»=</em></span></p>
<div class="sourceCode" id="cb8" data-file="src/initial_conditions/normalize_power_spectrum.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>&lt;&lt;gsl-integrate-qagiu&gt;&gt;</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>&lt;&lt;top-hat-function&gt;&gt;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>PowerSpectrum normalize_power_spectrum(</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>    PowerSpectrum <span class="at">const</span> &amp;P,</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    Config <span class="at">const</span> &amp;cosmology)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>{</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  <span class="dt">double</span> k_lower = <span class="dv">2</span> * M_PI / box.L;</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  <span class="dt">double</span> epsabs = <span class="fl">1e-6</span>, epsrel = <span class="fl">1e-6</span>;</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="dt">double</span> sigma8 = cosmology[<span class="st">&quot;sigma8&quot;</span>].as&lt;<span class="dt">double</span>&gt;();</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>  &lt;&lt;define-integrand&gt;&gt;</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>  <span class="dt">double</span> x = integrate_qagiu(</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>    integrand, k_lower, epsabs, epsrel);</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>  <span class="dt">double</span> A = sigma8 * sigma8 / x;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;Normalised power spectrum, A = &quot;</span> &lt;&lt; A &lt;&lt; <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>  <span class="cf">return</span> [=] (<span class="dt">double</span> k) {</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a>    <span class="cf">return</span> A * P(k);</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>  };</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Here we used some helper functions to encapsulate the GSL integration routines into a more friendly C++ wrapper, specified in the supplementary material.</p>
<h2 id="compute-initial-potential">Compute initial potential</h2>
<p>We now apply the desired power spectrum to the previously generated white noise. This is done by transforming the white noise to the Fourier domain, multiplying it by the square root of the power spectrum, and then transforming back again. We use a C++ wrapper around the FFTW3 library <span class="citation" data-cites="FFTW3">(Frigo and Johnson 2005)</span>, which is listed in the appendix. The wrapper class <code>RFFT3</code> allocates two <code>vector</code>s of memory for the input and output data. This is done using the FFTW routines, which ensure proper memory alignment for optimal algorithm efficiency. Note that our wrapper divides the result of the FFT computation by <span class="math inline">\(N^3\)</span> to normalise the end result, an action which FFTW omits.</p>
<div class="annotated-code">
<p><span><em>«src/initial_conditions/apply_power_spectrum.cc»=</em></span></p>
<div class="sourceCode" id="cb9" data-file="src/initial_conditions/apply_power_spectrum.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;fft.hh&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="dt">void</span> compute_potential(</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; &amp;field,</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    PowerSpectrum <span class="at">const</span> &amp;P)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>{</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  RFFT3 rfft(box);</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  <span class="bu">std::</span>copy(field.begin(), field.end(),</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>            rfft.real_space.begin());</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  rfft.forward_transform();</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  &lt;&lt;apply-power-spectrum&gt;&gt;</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  rfft.backward_transform();</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  <span class="bu">std::</span>copy(rfft.real_space.begin(), rfft.real_space.end(),</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>            field.begin());</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Since we’re working with a discrete Fourier transform and not the continuous used to normalise the power spectrum, we need to make sure not to lose any factors of <span class="math inline">\(N\)</span> or <span class="math inline">\(L\)</span>. In practice this means we need to divide the power spectrum by the physical volume of a single voxel.</p>
<p>Also, we divide by <span class="math inline">\(k^2\)</span> to compute the Zeldovich velocity potential, whereas the power spectrum specifies the linearly extrapolated power in the density perturbations.</p>
<p>We skip the first element of the array by starting on index <code>{0, 0, 1}</code> and iterating from 1 to <span class="math inline">\({\rm size} - 1\)</span>. The index of <code>{0, 0, 0}</code> coincides with <span class="math inline">\(k^2 = 0\)</span>, sometimes referred to as the <em>DC component</em>. This amplitude gives the summed value of all the (real-space) values in the field. The potential is gauge invariant, so the DC component is of no influence. Moreover, it would give us a division by zero if we were to try to compute it, resulting in a potential containing only <code>NaN</code>s.</p>
<div class="annotated-code">
<p><span><em>«apply-power-spectrum»=</em></span></p>
<div class="sourceCode" id="apply-power-spectrum"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="apply-power-spectrum-1"><a href="#apply-power-spectrum-1" aria-hidden="true"></a><span class="kw">auto</span> f_shape = box.rfft_shape();</span>
<span id="apply-power-spectrum-2"><a href="#apply-power-spectrum-2" aria-hidden="true"></a><span class="bu">std::</span>array&lt;<span class="dt">size_t</span>, <span class="dv">3</span>&gt; loc = {<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>};</span>
<span id="apply-power-spectrum-3"><a href="#apply-power-spectrum-3" aria-hidden="true"></a><span class="dt">double</span> v = pow(box.L / box.N, <span class="fl">3.0</span>);</span>
<span id="apply-power-spectrum-4"><a href="#apply-power-spectrum-4" aria-hidden="true"></a></span>
<span id="apply-power-spectrum-5"><a href="#apply-power-spectrum-5" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">1</span>; i &lt; box.rfft_size(); ++i) {</span>
<span id="apply-power-spectrum-6"><a href="#apply-power-spectrum-6" aria-hidden="true"></a>  <span class="dt">double</span> k = box.k_abs(loc);</span>
<span id="apply-power-spectrum-7"><a href="#apply-power-spectrum-7" aria-hidden="true"></a>  rfft.fourier_space[i] *= sqrt(P(k) / v) / (k * k);</span>
<span id="apply-power-spectrum-8"><a href="#apply-power-spectrum-8" aria-hidden="true"></a>  increment_index&lt;<span class="dv">3</span>&gt;(f_shape, loc);</span>
<span id="apply-power-spectrum-9"><a href="#apply-power-spectrum-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h1 id="the-adhesion-model">The Adhesion model</h1>
<p>Now that we have set up the initial conditions, we can run the adhesion model. Given a time <span class="math inline">\(t\)</span>, which is an alias for the <em>growing mode</em> solution of the linearised equations of structure formation, we can compute the regular triangulation weighted by the potential.</p>
<h2 id="theory">Theory</h2>
<p>Normally, we derive the fact that we can solve the adhesion model using regular triangulations from existing solutions <span class="citation" data-cites="Hopf1950">(Hopf 1950)</span> of the equation of motion, Burgers equation, <span id="eq:burgers-equation" class="eqnos"><span class="math display">\[\partial_t {\bf v} + ({\bf v} \cdot {\bf \nabla}) {\bf v} = \nu \nabla^2 {\bf v}.\]</span><span class="eqnos-number">(4)</span></span>  We may also understand this idea from a more kinematic point of view.</p>
<p>We assume an ensemble of particles moving by a potential <span class="math inline">\(\Phi_0({\bf q})\)</span> from their starting position <span class="math inline">\({\bf q}\)</span> to a target position <span class="math inline">\({\bf x}\)</span>,</p>
<p><span id="eq:zeldovich" class="eqnos"><span class="math display">\[{\bf x} = {\bf q} - t {\bf \nabla} \Phi_0({\bf q}).\]</span><span class="eqnos-number">(5)</span></span> </p>
<p>This is known as the Zeldovich approximation <span class="citation" data-cites="Zeldovich1970 Shandarin1989">(Zeldovich 1970; Shandarin and Zeldovich 1989)</span>. This has the problem that particles continue to move in a straight line, even after structures form. We’d like to have particles adhere together once they form structures, hence the name: <em>adhesion model</em>.</p>
<div id="fig:zeldovich" class="fignos">
<figure>
<img src="figures/ze.svg" alt="" /><figcaption><span>Figure 6:</span> The Zeldovich Approximation. Each particle is given a velocity equal to <span class="math inline">\(v = -\nabla \Phi_0\)</span>. Structures form, but there is no dynamics involved.</figcaption>
</figure>
</div>
<p>We can rewrite Equation <a href="#eq:zeldovich">5</a> by integrating,</p>
<p><span id="eq:zeldovich-potential" class="eqnos"><span class="math display">\[{\bf x} = {\bf \nabla_q}\left(\frac{q^2}{2} - t \Phi_0({\bf q}) + C\right) = {\bf \nabla_q} \varphi\]</span><span class="eqnos-number">(6)</span></span> </p>
<p>introducing the new potential <span class="math inline">\(\varphi({\bf q}) = q^2/2 - t\Phi_0\)</span>. The adhesion model is found by using not the potential <span class="math inline">\(\varphi\)</span> but its <em>convex hull</em> <span class="math inline">\(\varphi_c\)</span>. The derivative of a convex function is monotonic, therefore particles can no longer cross as they do in the Zeldovich Approximation.</p>
<p>Equation <a href="#eq:zeldovich-potential">6</a> can be further rewritten. Taking <span class="math inline">\(C = x^2/2\)</span> we get,</p>
<p><span id="eq:zeldovich-par" class="eqnos"><span class="math display">\[{\bf \nabla_q} \left(({\bf q} - {\bf x})^2 - 2t\Phi_0\right) = 0.\]</span><span class="eqnos-number">(7)</span></span> </p>
<h3 id="the-power-diagram">The power diagram</h3>
<p>We won’t be computing the convex hull of <span class="math inline">\(\varphi\)</span> explicitly. In stead we use the regular triangulation algorithm. The regular triangulation is the dual of the power diagram. The power diagram is the weighted generalisation of the Voronoi tessellation. Given a subset of points <span class="math inline">\(S \in Q\)</span>, we define a cell <span class="math inline">\(V_u\)</span> in the power diagram as follows:</p>
<p><span id="eq:power-diagram" class="eqnos"><span class="math display">\[V_u = \left\{ {\bf x} \in X \big| ({\bf u} - {\bf x})^2 - w_u \le ({\bf v} - {\bf x})^2 - w_v \forall {\bf v} \in S \right\}.\]</span><span class="eqnos-number">(8)</span></span></p>
<p>This is the same as minimising the distance function</p>
<p><span id="eq:distance-function" class="eqnos"><span class="math display">\[d({\bf x}) = \min_q \left[({\bf q} - {\bf x})^2 - w({\bf q})\right].\]</span><span class="eqnos-number">(9)</span></span> </p>
<p>At the minimum, we know that the derivative should vanish. Taking <span class="math inline">\(q^{\star}\)</span> to be the position at which the minimum is attained we may write,</p>
<p><span id="eq:power-solution" class="eqnos"><span class="math display">\[{\bf \nabla_q}\left(({\bf q} - {\bf x})^2 - w({\bf q})\right)|_{q=q^{\star}} = 0\]</span><span class="eqnos-number">(10)</span></span> </p>
<p>Setting the weights to,</p>
<p><span class="math display">\[w({\bf q}) = 2 t \Phi_0({\bf q}),\]</span></p>
<p>retrieves an expression similar to Equation <a href="#eq:zeldovich-par">7</a>. The only difference is that in Equation <a href="#eq:distance-function">9</a>, we took a <em>global minimum</em>, whereas in the Zeldovich approximation, <em>any</em> combination of <span class="math inline">\({\bf x}\)</span> and <span class="math inline">\({\bf q}\)</span> that solves Equation <a href="#eq:zeldovich-par">7</a> is valid.</p>
<div id="fig:adhesion" class="fignos">
<figure>
<img src="figures/adhesion.png" alt="" /><figcaption><span>Figure 7:</span> The adhesion model. We follow the same initial conditions as in Figure <a href="#fig:zeldovich">6</a>. This 2D example was produced by computing the convex hull of <span class="math inline">\(\varphi = q^2/2 - t \Phi_0\)</span> (first panel). The second panel shows the resulting regular triangulation. We have given a different colour to regions that are part of filaments and clusters. The third panel shows the power diagram. The mass of filaments is shown in blue colour, the mass of nodes is shown by size of the circles.</figcaption>
</figure>
</div>
<p>This argument is a summary of the underlying theory. We refer to <span class="citation" data-cites="Hidding2018">Hidding et al. (2018)</span> for more detail. In Figure <a href="#fig:adhesion">7</a> we show the adhesion model in 2d. In 2d, each edge in the regular triangulation matches a perpendicular one in the power diagram. In the voids we see the individual power cells that surround the position of the Zeldovich displaced particles. Where, in the Zeldovich Approximation structures formed, we see structures again, but this time they are represented by triangles and edges in the regular triangulation that exceed their sizes in the original grid.</p>
<h2 id="cgal-geometry-kernels">CGAL Geometry kernels</h2>
<p>CGAL comes with a set of <em>geometry kernels</em>. Each kernel bundles basic type definitions like <code>Point</code>, <code>Vector</code>, <code>Circle</code>, etc. and geometric operations on those types. Depending on the requirements of the programmer, we can choose different implementations of these concepts. These implementations vary in representation of real numbers, vector quantities, and how geometric operations are computed on them. Some abstract applications require an exact representation of numbers while other more cosmological applications can afford to be more liberal with regards to exactness.</p>
<p>The algorithms that actually do the advanced geometric computations, like the regular triangulations we use, are implemented in generic terms using C++ template techniques. We need to supply those algorithms the correct geometry kernel for our application. This is why all CGAL programs start with a list of template type definitions.</p>
<p>In our case, what we need is a double precision floating point representation of numbers, while retaining logical consistency in geometric predicates, of which the co-linearity test is the most obvious example. This is provided by the <code>Exact_predicates_inexact_constructions_kernel</code> kernel.</p>
<p>We collect those type definitions in a separate header file:</p>
<div class="annotated-code">
<p><span><em>«src/cgal_base.hh»=</em></span></p>
<div class="sourceCode" id="cb10" data-file="src/cgal_base.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;CGAL/Regular_triangulation_3.h&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="kw">using</span> K = CGAL::Exact_predicates_inexact_constructions_kernel;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>&lt;&lt;regular-triangulation-type&gt;&gt;</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="kw">typedef</span> K::Vector_3           Vector;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a><span class="kw">typedef</span> RT::Bare_point        Point;</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a><span class="kw">typedef</span> RT::Edge              Edge;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a><span class="kw">typedef</span> RT::Weighted_point    Weighted_point;</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a><span class="kw">typedef</span> RT::Segment           Segment;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a><span class="kw">typedef</span> RT::Tetrahedron       Tetrahedron;</span></code></pre></div>
</div>
<p>Since we’ll be using bare (weightless) points, weighted points, and vectors we defined aliases for those types. Note that CGAL is particular about the difference between points and vectors. Points are locations without absolute properties, whereas vectors describe how to get from one point to the other. Internally they can have the same numerical representation, but this may not strictly be the case for all geometry kernels.</p>
<p>We enable two versions of the code: serial and parallel. The parallel version requires <em>Threading Building Blocks</em> to be installed. The regular triangulation data structure gets tagged with <code>CGAL::Parallel_tag</code> which enables parallel versions of the algorithm.</p>
<div class="annotated-code">
<p><span><em>«regular-triangulation-type»=</em></span></p>
<div class="sourceCode" id="regular-triangulation-type"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="regular-triangulation-type-1"><a href="#regular-triangulation-type-1" aria-hidden="true"></a><span class="pp">#ifdef CGAL_LINKED_WITH_TBB</span></span>
<span id="regular-triangulation-type-2"><a href="#regular-triangulation-type-2" aria-hidden="true"></a>  <span class="kw">using</span> TDS = CGAL::Triangulation_data_structure_3&lt;</span>
<span id="regular-triangulation-type-3"><a href="#regular-triangulation-type-3" aria-hidden="true"></a>      CGAL::Regular_triangulation_vertex_base_3&lt;K&gt;,</span>
<span id="regular-triangulation-type-4"><a href="#regular-triangulation-type-4" aria-hidden="true"></a>      CGAL::Regular_triangulation_cell_base_3&lt;K&gt;,</span>
<span id="regular-triangulation-type-5"><a href="#regular-triangulation-type-5" aria-hidden="true"></a>      CGAL::Parallel_tag&gt;;</span>
<span id="regular-triangulation-type-6"><a href="#regular-triangulation-type-6" aria-hidden="true"></a></span>
<span id="regular-triangulation-type-7"><a href="#regular-triangulation-type-7" aria-hidden="true"></a>  <span class="kw">using</span> RT = CGAL::Regular_triangulation_3&lt;K, TDS&gt;;</span>
<span id="regular-triangulation-type-8"><a href="#regular-triangulation-type-8" aria-hidden="true"></a><span class="pp">#else</span></span>
<span id="regular-triangulation-type-9"><a href="#regular-triangulation-type-9" aria-hidden="true"></a>  <span class="kw">using</span> RT = CGAL::Regular_triangulation_3&lt;K&gt;;</span>
<span id="regular-triangulation-type-10"><a href="#regular-triangulation-type-10" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
<h2 id="adhesion-header">Adhesion header</h2>
<p>The adhesion computation is stored in an <code>Adhesion</code> object.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion.hh»=</em></span></p>
<div class="sourceCode" id="cb11" data-file="src/adhesion.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;boxparam.hh&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cgal_base.hh&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a><span class="kw">class</span> Adhesion</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>{</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>  &lt;&lt;adhesion-members&gt;&gt;</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>  &lt;&lt;adhesion-node-type&gt;&gt;</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  &lt;&lt;adhesion-node-<span class="kw">struct</span>&gt;&gt;</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>  Adhesion(</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; <span class="at">const</span> &amp;potential,</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>    <span class="dt">double</span> t);</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>  &lt;&lt;adhesion-methods&gt;&gt;</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h3 id="adhesion-members">Adhesion members</h3>
<p>The <code>Adhesion</code> class stores the time parameter, the regular triangulation data structure and a list of vertices.</p>
<div class="annotated-code">
<p><span><em>«adhesion-members»=</em></span></p>
<div class="sourceCode" id="adhesion-members"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="adhesion-members-1"><a href="#adhesion-members-1" aria-hidden="true"></a><span class="dt">double</span>                      time;</span>
<span id="adhesion-members-2"><a href="#adhesion-members-2" aria-hidden="true"></a>&lt;&lt;tbb-lock-member&gt;&gt;</span>
<span id="adhesion-members-3"><a href="#adhesion-members-3" aria-hidden="true"></a>RT                          rt;</span>
<span id="adhesion-members-4"><a href="#adhesion-members-4" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;Weighted_point&gt; vertices;</span></code></pre></div>
</div>
<p>Additionally, if we’re running with TBB enabled, we have to include a locking data structure.</p>
<h3 id="adhesion-methods">Adhesion methods</h3>
<p>We define methods for retrieving information from the regular triangulation.</p>
<div class="annotated-code">
<p><span><em>«adhesion-methods»=</em></span></p>
<div class="sourceCode" id="adhesion-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="adhesion-methods-1"><a href="#adhesion-methods-1" aria-hidden="true"></a><span class="dt">int</span> edge_count(RT::Cell_handle h, <span class="dt">double</span> threshold) <span class="at">const</span>;</span>
<span id="adhesion-methods-2"><a href="#adhesion-methods-2" aria-hidden="true"></a>Vector velocity(RT::Cell_handle c) <span class="at">const</span>;</span>
<span id="adhesion-methods-3"><a href="#adhesion-methods-3" aria-hidden="true"></a></span>
<span id="adhesion-methods-4"><a href="#adhesion-methods-4" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; get_walls(<span class="dt">double</span> threshold) <span class="at">const</span>;</span>
<span id="adhesion-methods-5"><a href="#adhesion-methods-5" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; get_filaments(<span class="dt">double</span> threshold) <span class="at">const</span>;</span>
<span id="adhesion-methods-6"><a href="#adhesion-methods-6" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;Node&gt; get_nodes(<span class="dt">double</span> threshold) <span class="at">const</span>;</span></code></pre></div>
</div>
<h2 id="computing-the-triangulation">Computing the triangulation</h2>
<p>We give each point in the grid a weight proportional to the velocity potential, <span class="math display">\[w_i = 2 t \Phi(q_i).\]</span> Then we insert these weighted points into the triangulation.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion/constructor.cc»=</em></span></p>
<div class="sourceCode" id="cb12" data-file="src/adhesion/constructor.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>Adhesion::Adhesion(</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    BoxParam <span class="at">const</span> &amp;box,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; <span class="at">const</span> &amp;potential,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    <span class="dt">double</span> t)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>  : time(t)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  &lt;&lt;tbb-initialise-lock&gt;&gt;</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>{</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  vertices.reserve(box.size());</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; box.size(); ++i)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>  {</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>    vertices.emplace_back(</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>      box.point&lt;Point&gt;(i),</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>      potential[i] * <span class="dv">2</span> * time);</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>  }</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>  rt.insert(</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>    vertices.begin(),</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>    vertices.end());</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="in-parallel-using-tbb">In parallel using TBB</h3>
<p>To implement a parallel version of the code, we need two extra bits of code in the class definition as well as the implementation of the constructor. We have to define a <em>lock data structure</em> which keeps a grid of localized locks.</p>
<div class="annotated-code">
<p><span><em>«tbb-lock-member»=</em></span></p>
<div class="sourceCode" id="tbb-lock-member"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="tbb-lock-member-1"><a href="#tbb-lock-member-1" aria-hidden="true"></a><span class="pp">#ifdef CGAL_LINKED_WITH_TBB</span></span>
<span id="tbb-lock-member-2"><a href="#tbb-lock-member-2" aria-hidden="true"></a>RT::Lock_data_structure     lock;</span>
<span id="tbb-lock-member-3"><a href="#tbb-lock-member-3" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
<p>Then in the constructor the lock has to be initialised with the shape of the box and an indication of the granularity of the grid on which to lock points.</p>
<div class="annotated-code">
<p><span><em>«tbb-initialise-lock»=</em></span></p>
<div class="sourceCode" id="tbb-initialise-lock"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="tbb-initialise-lock-1"><a href="#tbb-initialise-lock-1" aria-hidden="true"></a><span class="pp">#ifdef CGAL_LINKED_WITH_TBB</span></span>
<span id="tbb-initialise-lock-2"><a href="#tbb-initialise-lock-2" aria-hidden="true"></a>, lock(CGAL::Bbox_3(</span>
<span id="tbb-initialise-lock-3"><a href="#tbb-initialise-lock-3" aria-hidden="true"></a>    <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>,</span>
<span id="tbb-initialise-lock-4"><a href="#tbb-initialise-lock-4" aria-hidden="true"></a>    box.L, box.L, box.L), box.N)</span>
<span id="tbb-initialise-lock-5"><a href="#tbb-initialise-lock-5" aria-hidden="true"></a>, rt(K(), &amp;lock)</span>
<span id="tbb-initialise-lock-6"><a href="#tbb-initialise-lock-6" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
<p>The CGAL regular triangulation code should take care of the rest. Note however, that in current versions of CGAL (4.12) this feature is highly unstable and has been known to produce segmentation faults. Work continues to improve the parallel algorithms.</p>
<h2 id="node-properties">Node properties</h2>
<p>We will first see how to extract properties of <em>nodes</em> from the regular triangulation. Later on, we’ll look at the duals of edges and faces to visualise the walls and filaments more directly.</p>
<p>To understand how we get to the shape of a tetrahedron, we first have to understand how triangulations in CGAL are stored and accessed.</p>
<h3 id="cgal-triangulation-data-structures">CGAL Triangulation data structures</h3>
<p>First of all, the points in a triangulation are stored in a separate list. We can retrieve the actual point belonging to a vertex by indexing that list. The triangulation data structure then only deals with <em>vertex handles</em>, which is just an alias for an integer.</p>
<p>Second, the triangulation itself stores a list of cells. Each cell has four vertex handles and four <em>cell handles</em> pointing to the neighbours of the cell. Again a cell handle may be implemented with as little as an integer index into the list of cells. The neighbouring cell handles are stored in the same order as the vertices, that is, each neighbouring cell corresponds to its opposite vertex.</p>
<p>Edges are not stored, but represented as a cell handle and two indices between zero and three (inclusive). Similarly, facets are represented as a cell handle and the opposite vertex. More about the CGAL triangulation data structure can be read in the <a href="https://doc.cgal.org/latest/TDS_3/index.html">CGAL manual</a>.</p>
<h3 id="node-types">Node types</h3>
<p>Any node in the power diagram can be of the type <em>void</em>, <em>kurtoparabolic</em>, <em>wall</em>, <em>filament</em>, <em>cluster</em> or <em>undefined</em>. This last category is a catch-all that really shouldn’t happen.</p>
<p>A <em>kurtoparabolic</em> <span class="citation" data-cites="Frisch2001">(Frisch and Bec 2001)</span> is a point where a wall ends in a void. In the Zeldovich approximation we would see a cusp here, so the kurtoparabolic points are equivalent to <span class="math inline">\(A_3\)</span> singularities in Arnold’s ADE classification <span class="citation" data-cites="Arnold1982 Hidding2014">(Arnold, Shandarin, and Zeldovich 1982; Hidding, Shandarin, and Van de Weygaert 2014)</span>.</p>
<div class="annotated-code">
<p><span><em>«adhesion-node-type»=</em></span></p>
<div class="sourceCode" id="adhesion-node-type"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="adhesion-node-type-1"><a href="#adhesion-node-type-1" aria-hidden="true"></a><span class="kw">enum</span> NodeType : <span class="dt">uint32_t</span> {</span>
<span id="adhesion-node-type-2"><a href="#adhesion-node-type-2" aria-hidden="true"></a>  VOID, KURTOPARABOLIC, WALL, FILAMENT, CLUSTER, UNDEFINED_NODE_TYPE</span>
<span id="adhesion-node-type-3"><a href="#adhesion-node-type-3" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<p>Other properties that we can ascribe to a node are its <em>position</em>, <em>velocity</em> and <em>mass</em>.</p>
<div class="annotated-code">
<p><span><em>«adhesion-node-struct»=</em></span></p>
<div class="sourceCode" id="adhesion-node-struct"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="adhesion-node-struct-1"><a href="#adhesion-node-struct-1" aria-hidden="true"></a><span class="kw">struct</span> Node {</span>
<span id="adhesion-node-struct-2"><a href="#adhesion-node-struct-2" aria-hidden="true"></a>  <span class="bu">std::</span>array&lt;<span class="dt">double</span>, <span class="dv">3</span>&gt; position;</span>
<span id="adhesion-node-struct-3"><a href="#adhesion-node-struct-3" aria-hidden="true"></a>  <span class="bu">std::</span>array&lt;<span class="dt">double</span>, <span class="dv">3</span>&gt; velocity;</span>
<span id="adhesion-node-struct-4"><a href="#adhesion-node-struct-4" aria-hidden="true"></a>  <span class="dt">double</span>    mass;</span>
<span id="adhesion-node-struct-5"><a href="#adhesion-node-struct-5" aria-hidden="true"></a>  NodeType  <span class="dt">node_type</span>;</span>
<span id="adhesion-node-struct-6"><a href="#adhesion-node-struct-6" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<p>Note that the masses of any cell other then the cluster cells carry no physical meaning, unless somehow corrected for the resolution of the box. If we double the resolution, the average mass of a void particle drops by a factor eight, the average mass of a wall particle by a factor four, and the average mass of a filament particle by a factor two. Also we know that the total mass is conserved.</p>
<p>On the other hand, part of the distribution in masses is determined by the kind of shapes a tetrahedron can take. We show all possibilities in Figure <a href="#fig:node-classes">8</a>.</p>
<div id="fig:node-classes" class="fignos">
<figure>
<img src="figures/node-classes.svg" alt="" /><figcaption><span>Figure 8:</span> Shapes of tetrahedra. Here we list all possible shapes a tetrahedron can take, given that we put a threshold on the length of the edges. Edges that are longer than the threshold are shown in solid red lines, dashed black edges are shorter than the threshold.</figcaption>
</figure>
</div>
<p>Note that there are several species of kurtoparabolic points. The ones listed under ‘kurtoparabolics’ have all their vertices connected by short edges. Most of these would show walls ending in voids, but there is one, kurtoparabolic <em>e</em>, which has a filament (and three wall segments) ending in a void.</p>
<p>There is a sixth tetrahedron for which the simple classification of void, wall, filament or cluster is ambiguous, namely wall type <em>c</em>. One of the faces of this tetrahedron would classify as a filament, but looking at the connectivity of the vertices this tetrahedron would classify as a wall. At such a tetrahedron a filament runs into a wall.</p>
<p>The filament and cluster classifications are completely unambiguous. Their number of long edges and number of components connected by short edges both uniquely determine their type.</p>
<p>Note, that when we render the power diagram we are not using this classification. When we show the walls we just take the dual of all the edges that exceed the threshold, and when we show filaments we take the dual of all faces of which all edges exceed the threshold. The different types of nodes show us how walls and filaments interconnect in a sampled regular triangulation.</p>
<h3 id="filtering-for-structures">Filtering for structures</h3>
<p>When we want to select filaments or clusters we need to count how many edges of a certain cell in the regular triangulation exceeds a given threshold. The function <code>Adhesion::edge_count</code> takes a cell handle and a threshold and returns the number of long edges. This count determines if the cell is part of a void, wall, filament or node.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">edge count</th>
<th>structure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td>void</td>
</tr>
<tr class="even">
<td style="text-align: right;">1 - 2</td>
<td>kurtoparabolic point</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3 - 4</td>
<td>wall</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td>filament</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td>node</td>
</tr>
</tbody>
</table>
<p>This table translates to the following helper function:</p>
<div class="annotated-code">
<p><span><em>«adhesion-type-from-edge-count»=</em></span></p>
<div class="sourceCode" id="adhesion-type-from-edge-count"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="adhesion-type-from-edge-count-1"><a href="#adhesion-type-from-edge-count-1" aria-hidden="true"></a><span class="kw">inline</span> Adhesion::NodeType type_from_edge_count(<span class="dt">int</span> n)</span>
<span id="adhesion-type-from-edge-count-2"><a href="#adhesion-type-from-edge-count-2" aria-hidden="true"></a>{</span>
<span id="adhesion-type-from-edge-count-3"><a href="#adhesion-type-from-edge-count-3" aria-hidden="true"></a>  <span class="cf">switch</span> (n) {</span>
<span id="adhesion-type-from-edge-count-4"><a href="#adhesion-type-from-edge-count-4" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">0</span>: <span class="cf">return</span> Adhesion::VOID;</span>
<span id="adhesion-type-from-edge-count-5"><a href="#adhesion-type-from-edge-count-5" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">1</span>:</span>
<span id="adhesion-type-from-edge-count-6"><a href="#adhesion-type-from-edge-count-6" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">2</span>: <span class="cf">return</span> Adhesion::KURTOPARABOLIC;</span>
<span id="adhesion-type-from-edge-count-7"><a href="#adhesion-type-from-edge-count-7" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">3</span>:</span>
<span id="adhesion-type-from-edge-count-8"><a href="#adhesion-type-from-edge-count-8" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">4</span>: <span class="cf">return</span> Adhesion::WALL;</span>
<span id="adhesion-type-from-edge-count-9"><a href="#adhesion-type-from-edge-count-9" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">5</span>: <span class="cf">return</span> Adhesion::FILAMENT;</span>
<span id="adhesion-type-from-edge-count-10"><a href="#adhesion-type-from-edge-count-10" aria-hidden="true"></a>    <span class="cf">case</span> <span class="dv">6</span>: <span class="cf">return</span> Adhesion::CLUSTER;</span>
<span id="adhesion-type-from-edge-count-11"><a href="#adhesion-type-from-edge-count-11" aria-hidden="true"></a>  }</span>
<span id="adhesion-type-from-edge-count-12"><a href="#adhesion-type-from-edge-count-12" aria-hidden="true"></a>  <span class="cf">return</span> Adhesion::UNDEFINED_NODE_TYPE;</span>
<span id="adhesion-type-from-edge-count-13"><a href="#adhesion-type-from-edge-count-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="counting-edges">Counting edges</h3>
<p>We count the number of edges that are incident to the cell <code>h</code> and exceed the distance squared <code>threshold</code>.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion/edge_count.cc»=</em></span></p>
<div class="sourceCode" id="cb13" data-file="src/adhesion/edge_count.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="dt">int</span> Adhesion::edge_count(RT::Cell_handle h, <span class="dt">double</span> threshold) <span class="at">const</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>{</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="dt">int</span> count = <span class="dv">0</span>;</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">1</span>; i &lt; <span class="dv">4</span>; ++i) {</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> j = <span class="dv">0</span>; j &lt; i; ++j) {</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>      <span class="kw">auto</span> segment = rt.segment(h, i, j);</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>      <span class="dt">double</span> l = segment.squared_length();</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>      <span class="cf">if</span> (l &gt; threshold) {</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>        ++count;</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>      }</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>    }</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>  }</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>  <span class="cf">return</span> count;</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="velocity">Velocity</h2>
<p>To compute the velocity of a particle (a node in the power diagram), we need to compute the gradient of the velocity potential over the corresponding cell in the regular triangulation. We can use CGAL here to do the hard work for us. The d-dimensional geometry kernel lets us compute the hyperplane associated with the four vertices of the cell in the triangulation.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion/velocity.cc»=</em></span></p>
<div class="sourceCode" id="cb14" data-file="src/adhesion/velocity.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;CGAL/Cartesian_d.h&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;CGAL/Kernel_d/Hyperplane_d.h&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="kw">typedef</span> CGAL::Cartesian_d&lt;<span class="dt">double</span>&gt;    LiftedK;</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="kw">typedef</span> CGAL::Point_d&lt;LiftedK&gt;       LiftedPoint;</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a><span class="kw">typedef</span> CGAL::Hyperplane_d&lt;LiftedK&gt;  HyperPlane;</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>&lt;&lt;velocity-define-infinity&gt;&gt;</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>&lt;&lt;velocity-lifted-point&gt;&gt;</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a>Vector Adhesion::velocity(RT::Cell_handle c) <span class="at">const</span> {</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a>  &lt;&lt;velocity-implementation&gt;&gt;</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>We’ll need a point at infinity to give the hyperplane an orientation.</p>
<div class="annotated-code">
<p><span><em>«velocity-define-infinity»=</em></span></p>
<div class="sourceCode" id="velocity-define-infinity"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="velocity-define-infinity-1"><a href="#velocity-define-infinity-1" aria-hidden="true"></a><span class="kw">constexpr</span> <span class="dt">double</span> infinity</span>
<span id="velocity-define-infinity-2"><a href="#velocity-define-infinity-2" aria-hidden="true"></a>  = <span class="bu">std::</span>numeric_limits&lt;<span class="dt">double</span>&gt;::infinity();</span></code></pre></div>
</div>
<p>CGAL’s d-dimensional kernel needs to be told how many coordinates there are in a point, so we write a little wrapper.</p>
<div class="annotated-code">
<p><span><em>«velocity-lifted-point»=</em></span></p>
<div class="sourceCode" id="velocity-lifted-point"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="velocity-lifted-point-1"><a href="#velocity-lifted-point-1" aria-hidden="true"></a><span class="kw">inline</span> LiftedPoint lifted_point(</span>
<span id="velocity-lifted-point-2"><a href="#velocity-lifted-point-2" aria-hidden="true"></a>    <span class="dt">double</span> x, <span class="dt">double</span> y, <span class="dt">double</span> z, <span class="dt">double</span> w)</span>
<span id="velocity-lifted-point-3"><a href="#velocity-lifted-point-3" aria-hidden="true"></a>{</span>
<span id="velocity-lifted-point-4"><a href="#velocity-lifted-point-4" aria-hidden="true"></a>  <span class="dt">double</span> p[<span class="dv">4</span>] = { x, y, z, w };</span>
<span id="velocity-lifted-point-5"><a href="#velocity-lifted-point-5" aria-hidden="true"></a>  <span class="cf">return</span> LiftedPoint(<span class="dv">4</span>, p, p + <span class="dv">4</span>);</span>
<span id="velocity-lifted-point-6"><a href="#velocity-lifted-point-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>We first need to convert the cell handle to its four lifted points.</p>
<div class="annotated-code">
<p><span><em>«velocity-implementation»=</em></span></p>
<div class="sourceCode" id="velocity-implementation"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="velocity-implementation-1"><a href="#velocity-implementation-1" aria-hidden="true"></a>LiftedPoint points[<span class="dv">4</span>];</span>
<span id="velocity-implementation-2"><a href="#velocity-implementation-2" aria-hidden="true"></a></span>
<span id="velocity-implementation-3"><a href="#velocity-implementation-3" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i)</span>
<span id="velocity-implementation-4"><a href="#velocity-implementation-4" aria-hidden="true"></a>{</span>
<span id="velocity-implementation-5"><a href="#velocity-implementation-5" aria-hidden="true"></a>  Weighted_point wp = rt.point(c, i);</span>
<span id="velocity-implementation-6"><a href="#velocity-implementation-6" aria-hidden="true"></a>  <span class="kw">auto</span> p = wp.point();</span>
<span id="velocity-implementation-7"><a href="#velocity-implementation-7" aria-hidden="true"></a>  <span class="kw">auto</span> w = wp.weight();</span>
<span id="velocity-implementation-8"><a href="#velocity-implementation-8" aria-hidden="true"></a>  points[i] = lifted_point(p.x(), p.y(), p.z(), w);</span>
<span id="velocity-implementation-9"><a href="#velocity-implementation-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Then we create the hyperplane associated with these points, taking care to have the orientation such that the normal is pointing in positive <code>w</code> direction. This is done by having the guide point <span class="math inline">\((0, 0, 0, -\infty)\)</span> on the negative side of the hyperplane.</p>
<div class="annotated-code">
<p><span><em>«velocity-implementation»+</em></span></p>
<div class="sourceCode" id="velocity-implementation"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="velocity-implementation-1"><a href="#velocity-implementation-1" aria-hidden="true"></a><span class="kw">auto</span> guide = lifted_point(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, -infinity);</span>
<span id="velocity-implementation-2"><a href="#velocity-implementation-2" aria-hidden="true"></a>HyperPlane h(points, points + <span class="dv">4</span>, guide, CGAL::ON_NEGATIVE_SIDE);</span></code></pre></div>
</div>
<p>Given the normal <span class="math inline">\(\vec{n}\)</span>, the velocity vector is given by <span class="math display">\[v_i = \frac{n_i}{2 t n_w},\]</span> where <span class="math inline">\(i\)</span> indexes the <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> components.</p>
<div class="annotated-code">
<p><span><em>«velocity-implementation»+</em></span></p>
<div class="sourceCode" id="velocity-implementation"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="velocity-implementation-1"><a href="#velocity-implementation-1" aria-hidden="true"></a><span class="kw">auto</span> normal = h.orthogonal_vector();</span>
<span id="velocity-implementation-2"><a href="#velocity-implementation-2" aria-hidden="true"></a><span class="kw">auto</span> v  = normal / (<span class="dv">2</span> * time * normal[<span class="dv">3</span>]);</span>
<span id="velocity-implementation-3"><a href="#velocity-implementation-3" aria-hidden="true"></a></span>
<span id="velocity-implementation-4"><a href="#velocity-implementation-4" aria-hidden="true"></a><span class="cf">return</span> Vector(v[<span class="dv">0</span>], v[<span class="dv">1</span>], v[<span class="dv">2</span>]);</span></code></pre></div>
</div>
<h2 id="getting-all-nodes">Getting all nodes</h2>
<p>We will retrieve the position, mass, velocity and node type of each dual vertex in the regular triangulation.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion/get_nodes.cc»=</em></span></p>
<div class="sourceCode" id="cb15" data-file="src/adhesion/get_nodes.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>&lt;&lt;adhesion-type-from-edge-count&gt;&gt;</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;Adhesion::Node&gt;</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>Adhesion::get_nodes(<span class="dt">double</span> threshold) <span class="at">const</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>{</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;Adhesion::Node&gt; result;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="kw">auto</span> c  = rt.finite_cells_begin();</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>            c != rt.finite_cells_end();</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a>            ++c) {</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>    <span class="bu">std::</span>array&lt;<span class="dt">double</span>, <span class="dv">3</span>&gt;  ps, vs;</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>    Point    p = rt.dual(c);</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>    Vector   v = velocity(c);</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; ++i) {</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>      ps[i] = p[i];</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a>      vs[i] = v[i];</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>    }</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>    NodeType n = type_from_edge_count(</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>                   edge_count(c, threshold));</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    <span class="dt">double</span>   m = rt.tetrahedron(c).volume();</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>    result.push_back(Adhesion::Node({ps, vs, m, n}));</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>  }</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>  <span class="cf">return</span> result;</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="the-power-diagram-1">The power diagram</h2>
<p>The power diagram is the dual of the regular triangulation. CGAL supports saving the power diagram directly as an OFF file, or alternatively to send information to GeomView. For our purpose these options are not good enough. Our goal is to make a picture of the structures. For this we need to filter out any structures below a certain threshold. Then we want to store the density of the walls along with the faces and the density of filaments along with the edges.</p>
<p>In this case we’ll store them as Wavefront OBJ files. This is a text based file format, so we can’t store too large amounts of data. However, it is well supported by most visualisation tool-kits and has the option to store a little bit of extra data in the texture coordinates. Texture coordinates are normally used to map images onto 3D surfaces, hence they have two dimensions, <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>. We’ll only use the <span class="math inline">\(u\)</span> coordinate to store the density of the walls. The procedure for saving OBJ files is given in the supplementary material.</p>
<p>We’ll define the function that computes the duals of the regular triangulation and stores it in a structure we call <code>Mesh&lt;Point, double&gt;</code>.</p>
<div class="annotated-code">
<p><span><em>«src/power_diagram.hh»=</em></span></p>
<div class="sourceCode" id="cb16" data-file="src/power_diagram.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cgal_base.hh&quot;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="at">extern</span> Mesh&lt;Point, <span class="dt">double</span>&gt; power_diagram_faces(</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  RT <span class="at">const</span> &amp;rt, <span class="dt">double</span> threshold);</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a><span class="at">extern</span> Mesh&lt;Point, <span class="dt">double</span>&gt; power_diagram_edges(</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>  RT <span class="at">const</span> &amp;rt, <span class="dt">double</span> threshold);</span></code></pre></div>
</div>
<h3 id="the-mesh-data-structure">The <code>Mesh</code> data structure</h3>
<p>The <code>Mesh</code> structure contains a vector of points <code>vertices</code>, a vector of integers <code>data</code> indexing into the <code>vertices</code> vector, and a vector of integers indicating the size of each polygon. Additional information on the polygons is stored in an vector of <code>Info</code>. In our application the <code>Info</code> datatype will be a <code>double</code> value indicating the density of the walls or filaments stored in the mesh.</p>
<div class="annotated-code">
<p><span><em>«src/mesh.hh»=</em></span></p>
<div class="sourceCode" id="cb17" data-file="src/mesh.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point, <span class="kw">typename</span> Info&gt;</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="kw">struct</span> Mesh</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>{</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;Point&gt;    vertices;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; data;</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; sizes;</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;Info&gt;     info;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>  &lt;&lt;mesh-methods&gt;&gt;</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<p>This definition of <code>Mesh</code> is slightly more involved than using a <code>vector&lt;vector&lt;unsigned&gt;&gt;</code> to encode the polygons of the mesh. However, the added complexity of such a data structure makes it harder to save and restore binary versions in standard data containers like HDF5. Also, when data sizes get very large, using one large vector to store the data is more efficient than using many smaller ones.</p>
<p>We defined two methods to the <code>Mesh</code> structure. The <code>size()</code> method gives the amount of polygons in the mesh.</p>
<div class="annotated-code">
<p><span><em>«mesh-methods»=</em></span></p>
<div class="sourceCode" id="mesh-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="mesh-methods-1"><a href="#mesh-methods-1" aria-hidden="true"></a><span class="dt">size_t</span> size() <span class="at">const</span> { <span class="cf">return</span> sizes.size(); }</span></code></pre></div>
</div>
<p>Similar to a <code>vector::push_back()</code>, <code>Mesh::push_back()</code> adds a polygon to the mesh.</p>
<div class="annotated-code">
<p><span><em>«mesh-methods»+</em></span></p>
<div class="sourceCode" id="mesh-methods"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="mesh-methods-1"><a href="#mesh-methods-1" aria-hidden="true"></a><span class="dt">void</span> push_back(</span>
<span id="mesh-methods-2"><a href="#mesh-methods-2" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; <span class="at">const</span> &amp;vertices,</span>
<span id="mesh-methods-3"><a href="#mesh-methods-3" aria-hidden="true"></a>  Info <span class="at">const</span> &amp;i)</span>
<span id="mesh-methods-4"><a href="#mesh-methods-4" aria-hidden="true"></a>{</span>
<span id="mesh-methods-5"><a href="#mesh-methods-5" aria-hidden="true"></a>  data.insert(data.end(), vertices.begin(), vertices.end());</span>
<span id="mesh-methods-6"><a href="#mesh-methods-6" aria-hidden="true"></a>  sizes.push_back(vertices.size());</span>
<span id="mesh-methods-7"><a href="#mesh-methods-7" aria-hidden="true"></a>  info.push_back(i);</span>
<span id="mesh-methods-8"><a href="#mesh-methods-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="obtaining-duals">Obtaining duals</h3>
<p>The implementation of <code>power_diagram_faces</code> loops over all edges in the regular triangulation. For each edge we check if its length exceeds the threshold, then collect the dual vertices and add the polygon to the mesh.</p>
<div class="annotated-code">
<p><span><em>«pd-walls-loop»=</em></span></p>
<div class="sourceCode" id="pd-walls-loop"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-walls-loop-1"><a href="#pd-walls-loop-1" aria-hidden="true"></a><span class="cf">for</span> (<span class="kw">auto</span> e = rt.finite_edges_begin();</span>
<span id="pd-walls-loop-2"><a href="#pd-walls-loop-2" aria-hidden="true"></a>      e != rt.finite_edges_end();</span>
<span id="pd-walls-loop-3"><a href="#pd-walls-loop-3" aria-hidden="true"></a>      ++e)</span>
<span id="pd-walls-loop-4"><a href="#pd-walls-loop-4" aria-hidden="true"></a>{</span>
<span id="pd-walls-loop-5"><a href="#pd-walls-loop-5" aria-hidden="true"></a>  &lt;&lt;pd-edge-check&gt;&gt;</span>
<span id="pd-walls-loop-6"><a href="#pd-walls-loop-6" aria-hidden="true"></a>  &lt;&lt;pd-collect-dual&gt;&gt;</span>
<span id="pd-walls-loop-7"><a href="#pd-walls-loop-7" aria-hidden="true"></a>  &lt;&lt;pd-add-to-mesh&gt;&gt;</span>
<span id="pd-walls-loop-8"><a href="#pd-walls-loop-8" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>In each iteration, we check if the edge is significant.</p>
<div class="annotated-code">
<p><span><em>«pd-edge-check»=</em></span></p>
<div class="sourceCode" id="pd-edge-check"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-edge-check-1"><a href="#pd-edge-check-1" aria-hidden="true"></a><span class="cf">if</span> (is_big_edge(rt, *e, threshold)) {</span>
<span id="pd-edge-check-2"><a href="#pd-edge-check-2" aria-hidden="true"></a>  <span class="cf">continue</span>;</span>
<span id="pd-edge-check-3"><a href="#pd-edge-check-3" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Next we extract the power diagram vertices of the wall by looping over all <em>incident cells</em> of the edge. Because the iteration of the incident cells is circular we cannot use a normal for-loop. In stead, we use a do-while loop where the predicate is evaluated <em>after</em> each iteration. We need to take care not to include the infinite cell that represents everything outside the triangulation. If the infinite cell is encountered, this means that the edge is on the boundary of the triangulation. In that case the entire facet is dropped from the output.</p>
<div class="annotated-code">
<p><span><em>«pd-collect-dual»=</em></span></p>
<div class="sourceCode" id="pd-collect-dual"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-collect-dual-1"><a href="#pd-collect-dual-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; polygon;</span>
<span id="pd-collect-dual-2"><a href="#pd-collect-dual-2" aria-hidden="true"></a><span class="kw">auto</span> first = rt.incident_cells(*e), c = first;</span>
<span id="pd-collect-dual-3"><a href="#pd-collect-dual-3" aria-hidden="true"></a><span class="dt">bool</span> ok = <span class="kw">true</span>;</span>
<span id="pd-collect-dual-4"><a href="#pd-collect-dual-4" aria-hidden="true"></a></span>
<span id="pd-collect-dual-5"><a href="#pd-collect-dual-5" aria-hidden="true"></a><span class="cf">do</span> {</span>
<span id="pd-collect-dual-6"><a href="#pd-collect-dual-6" aria-hidden="true"></a>  <span class="cf">if</span> (rt.is_infinite(++c)) {</span>
<span id="pd-collect-dual-7"><a href="#pd-collect-dual-7" aria-hidden="true"></a>      ok = <span class="kw">false</span>;</span>
<span id="pd-collect-dual-8"><a href="#pd-collect-dual-8" aria-hidden="true"></a>      <span class="cf">break</span>;</span>
<span id="pd-collect-dual-9"><a href="#pd-collect-dual-9" aria-hidden="true"></a>  }</span>
<span id="pd-collect-dual-10"><a href="#pd-collect-dual-10" aria-hidden="true"></a></span>
<span id="pd-collect-dual-11"><a href="#pd-collect-dual-11" aria-hidden="true"></a>  polygon.push_back(get_dual_vertex(c));</span>
<span id="pd-collect-dual-12"><a href="#pd-collect-dual-12" aria-hidden="true"></a>} <span class="cf">while</span> (c != first);</span></code></pre></div>
</div>
<p>When all dual vertices have been added to the mesh (and the infinite cell was not encountered) we can add the resulting polygon to the mesh.</p>
<div class="annotated-code">
<p><span><em>«pd-add-to-mesh»=</em></span></p>
<div class="sourceCode" id="pd-add-to-mesh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-add-to-mesh-1"><a href="#pd-add-to-mesh-1" aria-hidden="true"></a><span class="cf">if</span> (ok) {</span>
<span id="pd-add-to-mesh-2"><a href="#pd-add-to-mesh-2" aria-hidden="true"></a>  <span class="dt">double</span> l = sqrt(rt.segment(*e).squared_length());</span>
<span id="pd-add-to-mesh-3"><a href="#pd-add-to-mesh-3" aria-hidden="true"></a>  mesh.push_back(polygon, l);</span>
<span id="pd-add-to-mesh-4"><a href="#pd-add-to-mesh-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Note that we have not yet defined the <code>get_dual_vertex</code> function in <em>«pd-collect-dual»</em>. We will do so now.</p>
<h4 id="dual-vertex">Dual vertex</h4>
<p>Every cell in the regular triangulation is associated with a vertex in the power diagram. We write a small helper function that obtains this dual vertex and caches it in a map. This ensures that every cell in the triangulation is mapped to a single unique vertex in the resulting mesh.</p>
<div class="annotated-code">
<p><span><em>«pd-dual-vertex»=</em></span></p>
<div class="sourceCode" id="pd-dual-vertex"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-dual-vertex-1"><a href="#pd-dual-vertex-1" aria-hidden="true"></a><span class="bu">std::</span>map&lt;RT::Cell_handle, <span class="dt">unsigned</span>&gt; cell_index;</span>
<span id="pd-dual-vertex-2"><a href="#pd-dual-vertex-2" aria-hidden="true"></a></span>
<span id="pd-dual-vertex-3"><a href="#pd-dual-vertex-3" aria-hidden="true"></a><span class="kw">auto</span> get_dual_vertex = [&amp;rt, &amp;cell_index, &amp;mesh] (</span>
<span id="pd-dual-vertex-4"><a href="#pd-dual-vertex-4" aria-hidden="true"></a>    RT::Cell_handle <span class="at">const</span> &amp;h) -&gt; <span class="dt">unsigned</span></span>
<span id="pd-dual-vertex-5"><a href="#pd-dual-vertex-5" aria-hidden="true"></a>{</span>
<span id="pd-dual-vertex-6"><a href="#pd-dual-vertex-6" aria-hidden="true"></a>  <span class="cf">if</span> (cell_index.count(h) == <span class="dv">0</span>)</span>
<span id="pd-dual-vertex-7"><a href="#pd-dual-vertex-7" aria-hidden="true"></a>  {</span>
<span id="pd-dual-vertex-8"><a href="#pd-dual-vertex-8" aria-hidden="true"></a>    cell_index[h] = mesh.vertices.size();</span>
<span id="pd-dual-vertex-9"><a href="#pd-dual-vertex-9" aria-hidden="true"></a>    mesh.vertices.push_back(rt.dual(h));</span>
<span id="pd-dual-vertex-10"><a href="#pd-dual-vertex-10" aria-hidden="true"></a>  }</span>
<span id="pd-dual-vertex-11"><a href="#pd-dual-vertex-11" aria-hidden="true"></a></span>
<span id="pd-dual-vertex-12"><a href="#pd-dual-vertex-12" aria-hidden="true"></a>  <span class="cf">return</span> cell_index[h];</span>
<span id="pd-dual-vertex-13"><a href="#pd-dual-vertex-13" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h3 id="testing-significance">Testing significance</h3>
<p>We do not want to get the dual of all edges in the regular triangulation. Only those edges that exceed a given length are ‘physical’ objects. We check if the squared length of the edge <code>e</code> is larger than the given threshold:</p>
<div class="annotated-code">
<p><span><em>«pd-is-big-edge»=</em></span></p>
<div class="sourceCode" id="pd-is-big-edge"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-is-big-edge-1"><a href="#pd-is-big-edge-1" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> is_big_edge(</span>
<span id="pd-is-big-edge-2"><a href="#pd-is-big-edge-2" aria-hidden="true"></a>    RT <span class="at">const</span> &amp;rt, RT::Edge <span class="at">const</span> &amp;e, <span class="dt">double</span> threshold)</span>
<span id="pd-is-big-edge-3"><a href="#pd-is-big-edge-3" aria-hidden="true"></a>{</span>
<span id="pd-is-big-edge-4"><a href="#pd-is-big-edge-4" aria-hidden="true"></a>  <span class="dt">double</span> l = rt.segment(e).squared_length();</span>
<span id="pd-is-big-edge-5"><a href="#pd-is-big-edge-5" aria-hidden="true"></a>  <span class="cf">return</span> l &lt; threshold;</span>
<span id="pd-is-big-edge-6"><a href="#pd-is-big-edge-6" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>For filaments this procedure is slightly more involved. A filament is the dual of a regular facet. The facet is encoded as a cell (one of the co-faces of the facet) and the vertex of that cell that is opposite the facet. We need to check the lengths of all the edges of the facet, so we need to iterate all combinations of vertices of the co-face not containing the given opposite vertex. This procedure is illustrated in Figure <a href="#fig:edge-iteration">9</a>.</p>
<div class="annotated-code">
<p><span><em>«pd-is-big-facet»=</em></span></p>
<div class="sourceCode" id="pd-is-big-facet"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="pd-is-big-facet-1"><a href="#pd-is-big-facet-1" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">bool</span> is_big_facet(</span>
<span id="pd-is-big-facet-2"><a href="#pd-is-big-facet-2" aria-hidden="true"></a>    RT <span class="at">const</span> &amp;rt, RT::Facet <span class="at">const</span> &amp;f, <span class="dt">double</span> threshold)</span>
<span id="pd-is-big-facet-3"><a href="#pd-is-big-facet-3" aria-hidden="true"></a>{</span>
<span id="pd-is-big-facet-4"><a href="#pd-is-big-facet-4" aria-hidden="true"></a>  RT::Cell_handle c = f.first;</span>
<span id="pd-is-big-facet-5"><a href="#pd-is-big-facet-5" aria-hidden="true"></a>  <span class="dt">unsigned</span>        k = f.second;</span>
<span id="pd-is-big-facet-6"><a href="#pd-is-big-facet-6" aria-hidden="true"></a></span>
<span id="pd-is-big-facet-7"><a href="#pd-is-big-facet-7" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> i = <span class="dv">0</span>; i &lt; <span class="dv">4</span>; ++i) {</span>
<span id="pd-is-big-facet-8"><a href="#pd-is-big-facet-8" aria-hidden="true"></a>    <span class="cf">if</span> (i == k) {</span>
<span id="pd-is-big-facet-9"><a href="#pd-is-big-facet-9" aria-hidden="true"></a>      <span class="cf">continue</span>;</span>
<span id="pd-is-big-facet-10"><a href="#pd-is-big-facet-10" aria-hidden="true"></a>    }</span>
<span id="pd-is-big-facet-11"><a href="#pd-is-big-facet-11" aria-hidden="true"></a></span>
<span id="pd-is-big-facet-12"><a href="#pd-is-big-facet-12" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> j = <span class="dv">0</span>; j &lt; i; ++j) {</span>
<span id="pd-is-big-facet-13"><a href="#pd-is-big-facet-13" aria-hidden="true"></a>      <span class="cf">if</span> (j == k) {</span>
<span id="pd-is-big-facet-14"><a href="#pd-is-big-facet-14" aria-hidden="true"></a>        <span class="cf">continue</span>;</span>
<span id="pd-is-big-facet-15"><a href="#pd-is-big-facet-15" aria-hidden="true"></a>      }</span>
<span id="pd-is-big-facet-16"><a href="#pd-is-big-facet-16" aria-hidden="true"></a></span>
<span id="pd-is-big-facet-17"><a href="#pd-is-big-facet-17" aria-hidden="true"></a>      <span class="cf">if</span> (rt.segment(c, i, j).squared_length() &lt; threshold) {</span>
<span id="pd-is-big-facet-18"><a href="#pd-is-big-facet-18" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="pd-is-big-facet-19"><a href="#pd-is-big-facet-19" aria-hidden="true"></a>      }</span>
<span id="pd-is-big-facet-20"><a href="#pd-is-big-facet-20" aria-hidden="true"></a>    }</span>
<span id="pd-is-big-facet-21"><a href="#pd-is-big-facet-21" aria-hidden="true"></a>  }</span>
<span id="pd-is-big-facet-22"><a href="#pd-is-big-facet-22" aria-hidden="true"></a></span>
<span id="pd-is-big-facet-23"><a href="#pd-is-big-facet-23" aria-hidden="true"></a>  <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="pd-is-big-facet-24"><a href="#pd-is-big-facet-24" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<div id="fig:edge-iteration" class="fignos">
<figure>
<img src="figures/edge-iteration.svg" style="width:50.0%" alt="" /><figcaption><span>Figure 9:</span> Selecting filaments. The dual of a facet in the regular triangulation is an edge in the power diagram. The power edge represents a filament in the adhesion model if all edges of the regular facet exceed the threshold. For this power edge <span class="math inline">\(\overline{AB}\)</span>, suppose we are checking the validity of the facet <span class="math inline">\(\overline{134}\)</span>. This facet is returned as the combination of a cell and the vertex opposite the facet, in this case <span class="math inline">\((\overline{A},\overline{2})\)</span>. To iterate the edges of this facet, we find all combinations <span class="math inline">\(\overline{ij}\)</span>, where <span class="math inline">\(1 \le i &lt; j \le 4\)</span>, and <span class="math inline">\(i, j \neq 2\)</span>.</figcaption>
</figure>
</div>
<h3 id="function-body-walls">Function body (walls)</h3>
<p>Collecting these steps, the rest of the implementation of <code>power_diagram_faces</code> is as follows:</p>
<div class="annotated-code">
<p><span><em>«src/power_diagram/faces.cc»=</em></span></p>
<div class="sourceCode" id="cb18" data-file="src/power_diagram/faces.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;power_diagram.hh&quot;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>&lt;&lt;pd-is-big-edge&gt;&gt;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; power_diagram_faces(</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>  RT <span class="at">const</span> &amp;rt,</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>  <span class="dt">double</span> threshold)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>{</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>  Mesh&lt;Point, <span class="dt">double</span>&gt; mesh;</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  &lt;&lt;pd-dual-vertex&gt;&gt;</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>  &lt;&lt;pd-walls-loop&gt;&gt;</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>  <span class="cf">return</span> mesh;</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="filaments">Filaments</h3>
<p>The implementation for the filaments is very similar. In the case of a facet in the regular triangulation, we only need to compute the dual of the two co-faces of the facet. Again, in CGAL the facet is represented as one of the two co-faces and the vertex opposite the facet. This means there are two ‘mirror’ representations of the same facet. To get the other co-facet we can query the triangulation for the mirror facet.</p>
<div class="annotated-code">
<p><span><em>«src/power_diagram/edges.cc»=</em></span></p>
<div class="sourceCode" id="cb19" data-file="src/power_diagram/edges.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;power_diagram.hh&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>&lt;&lt;pd-is-big-facet&gt;&gt;</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; power_diagram_edges(</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  RT <span class="at">const</span> &amp;rt,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="dt">double</span> threshold)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>{</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>  Mesh&lt;Point, <span class="dt">double</span>&gt; mesh;</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>  &lt;&lt;pd-dual-vertex&gt;&gt;</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="kw">auto</span> f = rt.finite_facets_begin();</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>       f != rt.finite_facets_end();</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>       ++f)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>  {</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>    <span class="cf">if</span> (!is_big_facet(rt, *f, threshold)) {</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>      <span class="cf">continue</span>;</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>    }</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>    <span class="dt">double</span> area = sqrt(rt.triangle(*f).squared_area());</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>    <span class="kw">auto</span> mirror = rt.mirror_facet(*f);</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>    <span class="cf">if</span> (rt.is_infinite(f-&gt;first) || rt.is_infinite(mirror.first)) {</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>      <span class="cf">continue</span>;</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a>    }</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; polygon;</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a>    polygon.push_back(get_dual_vertex(f-&gt;first));</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a>    polygon.push_back(get_dual_vertex(mirror.first));</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true"></a>    mesh.push_back(polygon, area);</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true"></a>  }</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true"></a></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true"></a>  <span class="cf">return</span> mesh;</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="retrieving-the-walls">Retrieving the walls</h3>
<p>We think it is important to make the step from abstract mathematics to physical model explicit. The implementation of the <code>get_walls</code> method is now trivial though.</p>
<div class="annotated-code">
<p><span><em>«src/adhesion/get_walls.cc»=</em></span></p>
<div class="sourceCode" id="cb20" data-file="src/adhesion/get_walls.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;power_diagram.hh&quot;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; Adhesion::get_walls(</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    <span class="dt">double</span> threshold) <span class="at">const</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>{</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>  <span class="cf">return</span> power_diagram_faces(rt, threshold);</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>}</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; Adhesion::get_filaments(</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="dt">double</span> threshold) <span class="at">const</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>{</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>  <span class="cf">return</span> power_diagram_edges(rt, threshold);</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h1 id="the-main-program">The main program</h1>
<p>We’re now ready to write the main program. It will read a configuration file from file and compute the adhesion model accordingly. Once the configuration is read, the workflow of actually computing the adhesion model is collected in a single function called <code>run</code>.</p>
<div class="annotated-code">
<p><span><em>«src/run.hh»=</em></span></p>
<div class="sourceCode" id="cb21" data-file="src/run.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;yaml-cpp/yaml.h&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="at">extern</span> <span class="dt">void</span> run(YAML::Node <span class="at">const</span> &amp;config);</span></code></pre></div>
</div>
<p>As we discuss each step in the workflow, we add code onto <em>«workflow»</em>.</p>
<div class="annotated-code">
<p><span><em>«src/run.cc»=</em></span></p>
<div class="sourceCode" id="cb22" data-file="src/run.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;exception&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;H5Cpp.h&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fmt/format.h&gt;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;run.hh&quot;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;initial_conditions.hh&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh_manipulation.hh&quot;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;plane.hh&quot;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;sphere.hh&quot;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;writers.hh&quot;</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;write_obj.hh&quot;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a><span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem;</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a><span class="dt">void</span> run(YAML::Node <span class="at">const</span> &amp;config)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>{</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a>  &lt;&lt;workflow&gt;&gt;</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="generate-initial-conditions">Generate initial conditions</h4>
<p>We create a <code>BoxParam</code> instance and generate the initial potential.</p>
<div class="annotated-code">
<p><span><em>«workflow»=</em></span></p>
<div class="sourceCode" id="workflow"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-1"><a href="#workflow-1" aria-hidden="true"></a><span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;# Using box with parameters:</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="workflow-2"><a href="#workflow-2" aria-hidden="true"></a>          &lt;&lt; config[<span class="st">&quot;box&quot;</span>] &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="workflow-3"><a href="#workflow-3" aria-hidden="true"></a>BoxParam box(</span>
<span id="workflow-4"><a href="#workflow-4" aria-hidden="true"></a>  config[<span class="st">&quot;box&quot;</span>][<span class="st">&quot;N&quot;</span>].as&lt;<span class="dt">int</span>&gt;(),</span>
<span id="workflow-5"><a href="#workflow-5" aria-hidden="true"></a>  config[<span class="st">&quot;box&quot;</span>][<span class="st">&quot;L&quot;</span>].as&lt;<span class="dt">double</span>&gt;());</span>
<span id="workflow-6"><a href="#workflow-6" aria-hidden="true"></a></span>
<span id="workflow-7"><a href="#workflow-7" aria-hidden="true"></a><span class="kw">auto</span> potential = generate_initial_potential(</span>
<span id="workflow-8"><a href="#workflow-8" aria-hidden="true"></a>  box, config);</span></code></pre></div>
</div>
<h4 id="write-initial-conditions-to-file">Write initial conditions to file</h4>
<p>We write the initial conditions to the output file for future reference. We have written some easy wrappers around the HDF5 routines, letting us write the statement in a single line. The wrappers can be found in the supplementary material. Next to saving the initial conditions, we also create two attributes, saving the box properties in the file.</p>
<div class="annotated-code">
<p><span><em>«workflow»+</em></span></p>
<div class="sourceCode" id="workflow"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-1"><a href="#workflow-1" aria-hidden="true"></a><span class="bu">std::</span>string output_filename</span>
<span id="workflow-2"><a href="#workflow-2" aria-hidden="true"></a>  = config[<span class="st">&quot;output&quot;</span>][<span class="st">&quot;hdf5&quot;</span>].as&lt;<span class="bu">std::</span>string&gt;();</span>
<span id="workflow-3"><a href="#workflow-3" aria-hidden="true"></a>fs::create_directories(</span>
<span id="workflow-4"><a href="#workflow-4" aria-hidden="true"></a>  fs::path(output_filename).parent_path());</span>
<span id="workflow-5"><a href="#workflow-5" aria-hidden="true"></a>H5::H5File output_file(output_filename, H5F_ACC_TRUNC);</span>
<span id="workflow-6"><a href="#workflow-6" aria-hidden="true"></a></span>
<span id="workflow-7"><a href="#workflow-7" aria-hidden="true"></a>write_attribute(output_file, <span class="st">&quot;N&quot;</span>, box.N);</span>
<span id="workflow-8"><a href="#workflow-8" aria-hidden="true"></a>write_attribute(output_file, <span class="st">&quot;L&quot;</span>, box.L);</span>
<span id="workflow-9"><a href="#workflow-9" aria-hidden="true"></a>write_vector_with_shape(</span>
<span id="workflow-10"><a href="#workflow-10" aria-hidden="true"></a>  output_file, <span class="st">&quot;potential&quot;</span>, potential, box.shape());</span></code></pre></div>
</div>
<h4 id="output-configuration">Output configuration</h4>
<p>We will write the walls and filaments to both HDF5 and OBJ files. In case of the OBJ files we only store a disc shaped selection, which makes the output easier to visualise. We have defined functions that can cut a mesh using planes and spheres. By cutting the mesh with a single sphere and two planes we extract a disc shaped region from the box. These cutting planes are stored in <code>mesh_shape</code>.</p>
<div class="annotated-code">
<p><span><em>«workflow»+</em></span></p>
<div class="sourceCode" id="workflow"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-1"><a href="#workflow-1" aria-hidden="true"></a><span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;Surface&lt;Point&gt;&gt;&gt; mesh_shape;</span>
<span id="workflow-2"><a href="#workflow-2" aria-hidden="true"></a>Point centre(box.L/<span class="dv">2</span>, box.L/<span class="dv">2</span>, box.L/<span class="dv">2</span>);</span>
<span id="workflow-3"><a href="#workflow-3" aria-hidden="true"></a>Vector dz(box.L/<span class="dv">15</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>);</span>
<span id="workflow-4"><a href="#workflow-4" aria-hidden="true"></a>mesh_shape.emplace_back(<span class="kw">new</span> Sphere&lt;K&gt;(centre, <span class="fl">0.4</span> * box.L));</span>
<span id="workflow-5"><a href="#workflow-5" aria-hidden="true"></a>mesh_shape.emplace_back(<span class="kw">new</span> Plane&lt;K&gt;(centre + dz, dz));</span>
<span id="workflow-6"><a href="#workflow-6" aria-hidden="true"></a>mesh_shape.emplace_back(<span class="kw">new</span> Plane&lt;K&gt;(centre - dz, -dz));</span></code></pre></div>
</div>
<p>The configuration specifies the threshold for structure selection and filenames to which the meshes are written.</p>
<div class="annotated-code">
<p><span><em>«workflow»+</em></span></p>
<div class="sourceCode" id="workflow"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-1"><a href="#workflow-1" aria-hidden="true"></a><span class="dt">double</span> threshold</span>
<span id="workflow-2"><a href="#workflow-2" aria-hidden="true"></a>  = config[<span class="st">&quot;output&quot;</span>][<span class="st">&quot;threshold&quot;</span>].as&lt;<span class="dt">double</span>&gt;(<span class="fl">0.0</span>);</span>
<span id="workflow-3"><a href="#workflow-3" aria-hidden="true"></a><span class="bu">std::</span>string walls_filename</span>
<span id="workflow-4"><a href="#workflow-4" aria-hidden="true"></a>  = config[<span class="st">&quot;output&quot;</span>][<span class="st">&quot;walls&quot;</span>].as&lt;<span class="bu">std::</span>string&gt;();</span>
<span id="workflow-5"><a href="#workflow-5" aria-hidden="true"></a><span class="bu">std::</span>string filaments_filename</span>
<span id="workflow-6"><a href="#workflow-6" aria-hidden="true"></a>  = config[<span class="st">&quot;output&quot;</span>][<span class="st">&quot;filaments&quot;</span>].as&lt;<span class="bu">std::</span>string&gt;();</span></code></pre></div>
</div>
<h2 id="main-loop">Main loop</h2>
<p>We read the time specification from the configuration, specify the output parameters, and loop over the specified times.</p>
<div class="annotated-code">
<p><span><em>«workflow»+</em></span></p>
<div class="sourceCode" id="workflow"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-1"><a href="#workflow-1" aria-hidden="true"></a><span class="kw">auto</span> time = config[<span class="st">&quot;run&quot;</span>][<span class="st">&quot;time&quot;</span>]</span>
<span id="workflow-2"><a href="#workflow-2" aria-hidden="true"></a>  .as&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&gt;();</span>
<span id="workflow-3"><a href="#workflow-3" aria-hidden="true"></a></span>
<span id="workflow-4"><a href="#workflow-4" aria-hidden="true"></a><span class="dt">unsigned</span> iteration = <span class="dv">0</span>;</span>
<span id="workflow-5"><a href="#workflow-5" aria-hidden="true"></a><span class="cf">for</span> (<span class="dt">double</span> t : time) {</span>
<span id="workflow-6"><a href="#workflow-6" aria-hidden="true"></a>  &lt;&lt;workflow-adhesion&gt;&gt;</span>
<span id="workflow-7"><a href="#workflow-7" aria-hidden="true"></a></span>
<span id="workflow-8"><a href="#workflow-8" aria-hidden="true"></a>  &lt;&lt;workflow-create-hdf5-group&gt;&gt;</span>
<span id="workflow-9"><a href="#workflow-9" aria-hidden="true"></a>  &lt;&lt;workflow-write-nodes&gt;&gt;</span>
<span id="workflow-10"><a href="#workflow-10" aria-hidden="true"></a>  &lt;&lt;workflow-write-obj&gt;&gt;</span>
<span id="workflow-11"><a href="#workflow-11" aria-hidden="true"></a>  ++iteration;</span>
<span id="workflow-12"><a href="#workflow-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>In each iteration we run the adhesion model. We then write results to a new HDF5 group, and also to a series of Wavefront OBJ files. We already covered the implementation of the adhesion model. All that’s left is calling the <code>Adhesion</code> constructor.</p>
<div class="annotated-code">
<p><span><em>«workflow-adhesion»=</em></span></p>
<div class="sourceCode" id="workflow-adhesion"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-adhesion-1"><a href="#workflow-adhesion-1" aria-hidden="true"></a><span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;Computing regular triangulation for t = &quot;</span></span>
<span id="workflow-adhesion-2"><a href="#workflow-adhesion-2" aria-hidden="true"></a>          &lt;&lt; t &lt;&lt; <span class="st">&quot; ...</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="workflow-adhesion-3"><a href="#workflow-adhesion-3" aria-hidden="true"></a>Adhesion adhesion(box, potential, t);</span></code></pre></div>
</div>
<h3 id="writing-output">Writing output</h3>
<p>In the workflow we can now write all this information about the nodes to the HDF5 file. First, for each snapshot we create a group in the HDF5 file.</p>
<div class="annotated-code">
<p><span><em>«workflow-create-hdf5-group»=</em></span></p>
<div class="sourceCode" id="workflow-create-hdf5-group"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-create-hdf5-group-1"><a href="#workflow-create-hdf5-group-1" aria-hidden="true"></a><span class="kw">auto</span> h5_group = output_file.createGroup(</span>
<span id="workflow-create-hdf5-group-2"><a href="#workflow-create-hdf5-group-2" aria-hidden="true"></a>  fmt::format(<span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span>, iteration));</span>
<span id="workflow-create-hdf5-group-3"><a href="#workflow-create-hdf5-group-3" aria-hidden="true"></a>write_attribute(h5_group, <span class="st">&quot;time&quot;</span>, t);</span></code></pre></div>
</div>
<p>Then we write the node information to that group.</p>
<div class="annotated-code">
<p><span><em>«workflow-write-nodes»=</em></span></p>
<div class="sourceCode" id="workflow-write-nodes"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-write-nodes-1"><a href="#workflow-write-nodes-1" aria-hidden="true"></a><span class="kw">auto</span> nodes = adhesion.get_nodes(threshold);</span>
<span id="workflow-write-nodes-2"><a href="#workflow-write-nodes-2" aria-hidden="true"></a>write_vector(h5_group, <span class="st">&quot;nodes&quot;</span>, nodes);</span></code></pre></div>
</div>
<h4 id="write-the-walls">Write the walls</h4>
<p>In case of the walls we write a selection to an OBJ file and the entire box to the HDF5 file.</p>
<div class="annotated-code">
<p><span><em>«workflow-write-obj»=</em></span></p>
<div class="sourceCode" id="workflow-write-obj"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-write-obj-1"><a href="#workflow-write-obj-1" aria-hidden="true"></a>{</span>
<span id="workflow-write-obj-2"><a href="#workflow-write-obj-2" aria-hidden="true"></a>  <span class="kw">auto</span> walls = adhesion.get_walls(threshold);</span>
<span id="workflow-write-obj-3"><a href="#workflow-write-obj-3" aria-hidden="true"></a>  <span class="bu">std::</span>string filename = fmt::format(</span>
<span id="workflow-write-obj-4"><a href="#workflow-write-obj-4" aria-hidden="true"></a>    walls_filename, fmt::arg(<span class="st">&quot;time&quot;</span>, t));</span>
<span id="workflow-write-obj-5"><a href="#workflow-write-obj-5" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;writing to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="workflow-write-obj-6"><a href="#workflow-write-obj-6" aria-hidden="true"></a></span>
<span id="workflow-write-obj-7"><a href="#workflow-write-obj-7" aria-hidden="true"></a>  <span class="bu">std::</span>ofstream ff(filename);</span>
<span id="workflow-write-obj-8"><a href="#workflow-write-obj-8" aria-hidden="true"></a>  <span class="kw">auto</span> selected_faces = select_mesh(walls, mesh_shape);</span>
<span id="workflow-write-obj-9"><a href="#workflow-write-obj-9" aria-hidden="true"></a>  write_faces_to_obj(ff, selected_faces);</span>
<span id="workflow-write-obj-10"><a href="#workflow-write-obj-10" aria-hidden="true"></a>  write_mesh(h5_group, <span class="st">&quot;faces&quot;</span>, walls);</span>
<span id="workflow-write-obj-11"><a href="#workflow-write-obj-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="write-the-filaments">Write the filaments</h4>
<p>The same goes for the filaments. The difference with the previous code block is the extra <code>false</code> parameter in the <code>select_mesh</code> call. This tells the polygon cutting algorithm that we are dealing with non-cyclic edges, whereas the walls are represented by polygons that are cyclic.</p>
<div class="annotated-code">
<p><span><em>«workflow-write-obj»+</em></span></p>
<div class="sourceCode" id="workflow-write-obj"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="workflow-write-obj-1"><a href="#workflow-write-obj-1" aria-hidden="true"></a>{</span>
<span id="workflow-write-obj-2"><a href="#workflow-write-obj-2" aria-hidden="true"></a>  <span class="kw">auto</span> filaments = adhesion.get_filaments(threshold);</span>
<span id="workflow-write-obj-3"><a href="#workflow-write-obj-3" aria-hidden="true"></a>  <span class="bu">std::</span>string filename = fmt::format(</span>
<span id="workflow-write-obj-4"><a href="#workflow-write-obj-4" aria-hidden="true"></a>    filaments_filename, fmt::arg(<span class="st">&quot;time&quot;</span>, t));</span>
<span id="workflow-write-obj-5"><a href="#workflow-write-obj-5" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;writing to &quot;</span> &lt;&lt; filename &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="workflow-write-obj-6"><a href="#workflow-write-obj-6" aria-hidden="true"></a></span>
<span id="workflow-write-obj-7"><a href="#workflow-write-obj-7" aria-hidden="true"></a>  <span class="bu">std::</span>ofstream ff(filename);</span>
<span id="workflow-write-obj-8"><a href="#workflow-write-obj-8" aria-hidden="true"></a>  <span class="kw">auto</span> selected_edges = select_mesh(filaments, mesh_shape, <span class="kw">false</span>);</span>
<span id="workflow-write-obj-9"><a href="#workflow-write-obj-9" aria-hidden="true"></a>  write_edges_to_obj(ff, selected_edges);</span>
<span id="workflow-write-obj-10"><a href="#workflow-write-obj-10" aria-hidden="true"></a>  write_mesh(h5_group, <span class="st">&quot;edges&quot;</span>, filaments);</span>
<span id="workflow-write-obj-11"><a href="#workflow-write-obj-11" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="main-function">Main function</h2>
<p>The <code>main</code> function provides the primary interface to the user. It parses command-line arguments, prints help if needed, loads the configuration, and runs the rest of the program by calling <code>run</code>.</p>
<div class="annotated-code">
<p><span><em>«cpp-default-config»=</em></span></p>
<div class="sourceCode" id="cpp-default-config"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cpp-default-config-1"><a href="#cpp-default-config-1" aria-hidden="true"></a><span class="at">const</span> <span class="dt">char</span> *default_config = <span class="st">R&quot;YAML(</span></span>
<span id="cpp-default-config-2"><a href="#cpp-default-config-2" aria-hidden="true"></a><span class="st"># Default configuration</span></span>
<span id="cpp-default-config-3"><a href="#cpp-default-config-3" aria-hidden="true"></a></span>
<span id="cpp-default-config-4"><a href="#cpp-default-config-4" aria-hidden="true"></a><span class="st">box:</span></span>
<span id="cpp-default-config-5"><a href="#cpp-default-config-5" aria-hidden="true"></a><span class="st">  N:      128       # logical box size</span></span>
<span id="cpp-default-config-6"><a href="#cpp-default-config-6" aria-hidden="true"></a><span class="st">  L:       50.0     # physical box size</span></span>
<span id="cpp-default-config-7"><a href="#cpp-default-config-7" aria-hidden="true"></a></span>
<span id="cpp-default-config-8"><a href="#cpp-default-config-8" aria-hidden="true"></a><span class="st">cosmology:</span></span>
<span id="cpp-default-config-9"><a href="#cpp-default-config-9" aria-hidden="true"></a><span class="st">  power-spectrum: Eisenstein &amp; Hu (no baryons)</span></span>
<span id="cpp-default-config-10"><a href="#cpp-default-config-10" aria-hidden="true"></a><span class="st">  h:        0.674   # Hubble parameter / 100</span></span>
<span id="cpp-default-config-11"><a href="#cpp-default-config-11" aria-hidden="true"></a><span class="st">  ns:       0.965   # primordial power spectrum index</span></span>
<span id="cpp-default-config-12"><a href="#cpp-default-config-12" aria-hidden="true"></a><span class="st">  Omega0:   1.0     # density in units of critical density</span></span>
<span id="cpp-default-config-13"><a href="#cpp-default-config-13" aria-hidden="true"></a><span class="st">  sigma8:   0.811   # amplitude over 8 Mpc/h</span></span>
<span id="cpp-default-config-14"><a href="#cpp-default-config-14" aria-hidden="true"></a></span>
<span id="cpp-default-config-15"><a href="#cpp-default-config-15" aria-hidden="true"></a><span class="st">run:</span></span>
<span id="cpp-default-config-16"><a href="#cpp-default-config-16" aria-hidden="true"></a><span class="st">  seed:     8</span></span>
<span id="cpp-default-config-17"><a href="#cpp-default-config-17" aria-hidden="true"></a><span class="st">  time:     [0.2, 0.5, 1.0]</span></span>
<span id="cpp-default-config-18"><a href="#cpp-default-config-18" aria-hidden="true"></a></span>
<span id="cpp-default-config-19"><a href="#cpp-default-config-19" aria-hidden="true"></a><span class="st">output:</span></span>
<span id="cpp-default-config-20"><a href="#cpp-default-config-20" aria-hidden="true"></a><span class="st">  hdf5:            output/lcdm.h5</span></span>
<span id="cpp-default-config-21"><a href="#cpp-default-config-21" aria-hidden="true"></a><span class="st">  walls:           output/lcdm-{time:02.1f}-walls.obj</span></span>
<span id="cpp-default-config-22"><a href="#cpp-default-config-22" aria-hidden="true"></a><span class="st">  filaments:       output/lcdm-{time:02.1f}-filaments.obj</span></span>
<span id="cpp-default-config-23"><a href="#cpp-default-config-23" aria-hidden="true"></a><span class="st">  threshold:       1.0</span></span>
<span id="cpp-default-config-24"><a href="#cpp-default-config-24" aria-hidden="true"></a><span class="st">)YAML&quot;</span>;</span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«src/main.cc»=</em></span></p>
<div class="sourceCode" id="cb23" data-file="src/main.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;argagg/argagg.hpp&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;yaml-cpp/yaml.h&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;run.hh&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>&lt;&lt;version&gt;&gt;</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>&lt;&lt;main-arguments&gt;&gt;</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>&lt;&lt;cpp-<span class="cf">default</span>-config&gt;&gt;</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>{</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>  &lt;&lt;parse-arguments&gt;&gt;</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a>  &lt;&lt;maybe-print-help&gt;&gt;</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>  &lt;&lt;maybe-print-version&gt;&gt;</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a>  &lt;&lt;maybe-print-defaults&gt;&gt;</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true"></a>  &lt;&lt;load-config&gt;&gt;</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true"></a>  &lt;&lt;run&gt;&gt;</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>First we parse the arguments using the specification given in the introduction.</p>
<div class="annotated-code">
<p><span><em>«parse-arguments»=</em></span></p>
<div class="sourceCode" id="parse-arguments"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="parse-arguments-1"><a href="#parse-arguments-1" aria-hidden="true"></a>argagg::parser_results args;</span>
<span id="parse-arguments-2"><a href="#parse-arguments-2" aria-hidden="true"></a><span class="cf">try</span> {</span>
<span id="parse-arguments-3"><a href="#parse-arguments-3" aria-hidden="true"></a>  args = argparser.parse(argc, argv);</span>
<span id="parse-arguments-4"><a href="#parse-arguments-4" aria-hidden="true"></a>} <span class="cf">catch</span> (<span class="at">const</span> <span class="bu">std::</span>exception&amp; e) {</span>
<span id="parse-arguments-5"><a href="#parse-arguments-5" aria-hidden="true"></a>  <span class="bu">std::</span>cerr &lt;&lt; e.what() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="parse-arguments-6"><a href="#parse-arguments-6" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_FAILURE;</span>
<span id="parse-arguments-7"><a href="#parse-arguments-7" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>If the <code>help</code> argument is given, we print the help message and exit.</p>
<div class="annotated-code">
<p><span><em>«maybe-print-help»=</em></span></p>
<div class="sourceCode" id="maybe-print-help"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="maybe-print-help-1"><a href="#maybe-print-help-1" aria-hidden="true"></a><span class="cf">if</span> (args[<span class="st">&quot;help&quot;</span>]) {</span>
<span id="maybe-print-help-2"><a href="#maybe-print-help-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;Adhesion model example code -- (C) 2018 Johan Hidding</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="maybe-print-help-3"><a href="#maybe-print-help-3" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; argparser;</span>
<span id="maybe-print-help-4"><a href="#maybe-print-help-4" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="maybe-print-help-5"><a href="#maybe-print-help-5" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>If the <code>version</code> argument is given, we print the software version and exit.</p>
<div class="annotated-code">
<p><span><em>«maybe-print-version»=</em></span></p>
<div class="sourceCode" id="maybe-print-version"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="maybe-print-version-1"><a href="#maybe-print-version-1" aria-hidden="true"></a><span class="cf">if</span> (args[<span class="st">&quot;version&quot;</span>]) {</span>
<span id="maybe-print-version-2"><a href="#maybe-print-version-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;amec v&quot;</span> &lt;&lt; VERSION &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="maybe-print-version-3"><a href="#maybe-print-version-3" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="maybe-print-version-4"><a href="#maybe-print-version-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>The <code>help</code> and <code>version</code> arguments are considered to be a standard interface for command-line programs. See for instance the <a href="https://www.gnu.org/prep/standards/standards.html">GNU Sofware Standards</a>.</p>
<p>If the <code>defaults</code> argument is given, we print the default configuration as specified in the introduction. The user can use this to write this configuration to a file and edit it to wishes accordingly.</p>
<div class="annotated-code">
<p><span><em>«maybe-print-defaults»=</em></span></p>
<div class="sourceCode" id="maybe-print-defaults"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="maybe-print-defaults-1"><a href="#maybe-print-defaults-1" aria-hidden="true"></a><span class="cf">if</span> (args[<span class="st">&quot;defaults&quot;</span>]) {</span>
<span id="maybe-print-defaults-2"><a href="#maybe-print-defaults-2" aria-hidden="true"></a>  <span class="bu">std::</span>cout &lt;&lt; default_config;</span>
<span id="maybe-print-defaults-3"><a href="#maybe-print-defaults-3" aria-hidden="true"></a>  <span class="cf">return</span> EXIT_SUCCESS;</span>
<span id="maybe-print-defaults-4"><a href="#maybe-print-defaults-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>If none of the <code>help</code>, <code>version</code> or <code>defaults</code> arguments is given, we proceed reading the configuration from file, or if no filename is given, use the defaults.</p>
<div class="annotated-code">
<p><span><em>«load-config»=</em></span></p>
<div class="sourceCode" id="load-config"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="load-config-1"><a href="#load-config-1" aria-hidden="true"></a>YAML::Node config;</span>
<span id="load-config-2"><a href="#load-config-2" aria-hidden="true"></a><span class="cf">if</span> (args[<span class="st">&quot;config&quot;</span>]) {</span>
<span id="load-config-3"><a href="#load-config-3" aria-hidden="true"></a>  <span class="kw">auto</span> config_file = args[<span class="st">&quot;config&quot;</span>].as&lt;<span class="bu">std::</span>string&gt;();</span>
<span id="load-config-4"><a href="#load-config-4" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;Reading `&quot;</span> &lt;&lt; config_file &lt;&lt; <span class="st">&quot;` for input.</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="load-config-5"><a href="#load-config-5" aria-hidden="true"></a>  config = YAML::LoadFile(config_file);</span>
<span id="load-config-6"><a href="#load-config-6" aria-hidden="true"></a>} <span class="cf">else</span> {</span>
<span id="load-config-7"><a href="#load-config-7" aria-hidden="true"></a>  <span class="bu">std::</span>clog &lt;&lt; <span class="st">&quot;No configuration given, proceeding with defaults.</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="load-config-8"><a href="#load-config-8" aria-hidden="true"></a>  config = YAML::Load(default_config);</span>
<span id="load-config-9"><a href="#load-config-9" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Now that the configuration is loaded, we are ready to run the program.</p>
<div class="annotated-code">
<p><span><em>«run»=</em></span></p>
<div class="sourceCode" id="run"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="run-1"><a href="#run-1" aria-hidden="true"></a>run(config);</span></code></pre></div>
</div>
<h1 id="python-bindings">Python bindings</h1>
<div class="annotated-code">
<p><span><em>«src/python/test.cc»=</em></span></p>
<div class="sourceCode" id="cb24" data-file="src/python/test.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pybind11/pybind11.h&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;pybind11/stl_bind.h&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cgal_base.hh&quot;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;surface.hh&quot;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;sphere.hh&quot;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;plane.hh&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh_manipulation.hh&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>PYBIND11_MAKE_OPAQUE(<span class="bu">std::</span>vector&lt;Point&gt;);</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>PYBIND11_MAKE_OPAQUE(<span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt;);</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>PYBIND11_MAKE_OPAQUE(<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;);</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a><span class="kw">namespace</span> py = pybind11;</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a><span class="dt">int</span> add(<span class="dt">int</span> i, <span class="dt">int</span> j) {</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a>    <span class="cf">return</span> i + j;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>}</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a>Mesh&lt;Point, <span class="dt">double</span>&gt; select_mesh_py(</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh,</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a>    py::list surfaces,</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a>    <span class="dt">bool</span> closed)</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a>{</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; m = mesh;</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="kw">auto</span> s : surfaces) {</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true"></a>        Surface&lt;Point&gt; *<span class="va">s_ptr</span> = s.cast&lt;Surface&lt;Point&gt; *&gt;();</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true"></a>        m = select_mesh(m, *<span class="va">s_ptr</span>, closed);</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true"></a>    }</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true"></a>    <span class="cf">return</span> m;</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true"></a>}</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true"></a></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true"></a>PYBIND11_MODULE(adhesion, m) {</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true"></a>    m.doc() = <span class="st">&quot;pybind11 example plugin&quot;</span>; <span class="co">// optional module docstring</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true"></a></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true"></a>    m.def(<span class="st">&quot;add&quot;</span>, &amp;add, <span class="st">&quot;A function which adds two numbers&quot;</span>);</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true"></a></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true"></a>    py::bind_vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt;&gt;(m, <span class="st">&quot;IndexVector&quot;</span>);</span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true"></a>    py::bind_vector&lt;<span class="bu">std::</span>vector&lt;Point&gt;&gt;(m, <span class="st">&quot;Vertices&quot;</span>);</span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true"></a>    py::bind_vector&lt;<span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt;&gt;(m, <span class="st">&quot;InfoVector&quot;</span>);</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true"></a></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Point&gt;(m, <span class="st">&quot;Point&quot;</span>)</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true"></a>        .def(py::init&lt;<span class="dt">double</span>, <span class="dt">double</span>, <span class="dt">double</span>&gt;())</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;x&quot;</span>, &amp;Point::x)</span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;y&quot;</span>, &amp;Point::y)</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;z&quot;</span>, &amp;Point::z);</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true"></a></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Vector&gt;(m, <span class="st">&quot;Vector&quot;</span>)</span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true"></a>        .def(py::init&lt;<span class="dt">double</span>, <span class="dt">double</span>, <span class="dt">double</span>&gt;())</span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;x&quot;</span>, &amp;Vector::x)</span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;y&quot;</span>, &amp;Vector::y)</span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true"></a>        .def_property_readonly(<span class="st">&quot;z&quot;</span>, &amp;Vector::z);</span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true"></a></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Mesh&lt;Point, <span class="dt">double</span>&gt;&gt;(m, <span class="st">&quot;Mesh&quot;</span>)</span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true"></a>        .def(py::init&lt;&gt;())</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true"></a>        .def_readonly(<span class="st">&quot;vertices&quot;</span>, &amp;Mesh&lt;Point,<span class="dt">double</span>&gt;::vertices)</span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true"></a>        .def_readonly(<span class="st">&quot;data&quot;</span>,     &amp;Mesh&lt;Point,<span class="dt">double</span>&gt;::data)</span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true"></a>        .def_readonly(<span class="st">&quot;sizes&quot;</span>,    &amp;Mesh&lt;Point,<span class="dt">double</span>&gt;::sizes)</span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true"></a>        .def_readonly(<span class="st">&quot;info&quot;</span>,     &amp;Mesh&lt;Point,<span class="dt">double</span>&gt;::info);</span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true"></a></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Surface&lt;Point&gt;&gt; surface(m, <span class="st">&quot;Surface&quot;</span>);</span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Sphere&lt;K&gt;&gt;(m, <span class="st">&quot;Sphere&quot;</span>, surface)</span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true"></a>        .def(py::init&lt;Point, <span class="dt">double</span>&gt;());</span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true"></a>    py::<span class="va">class_</span>&lt;Plane&lt;K&gt;&gt;(m, <span class="st">&quot;Plane&quot;</span>, surface)</span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true"></a>        .def(py::init&lt;Point, Vector&gt;());</span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true"></a></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true"></a>    m.def(<span class="st">&quot;select_mesh&quot;</span>, &amp;select_mesh_py, <span class="st">&quot;Select part of a mesh&quot;</span>, py::arg(<span class="st">&quot;mesh&quot;</span>), py::arg(<span class="st">&quot;surfaces&quot;</span>), py::arg(<span class="st">&quot;closed&quot;</span>) = <span class="kw">true</span>);</span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h1 id="appendix">Appendix</h1>
<p>This appendix provides convenience interfaces to the FFTW3, GSL integration and HDF5 libraries.</p>
<h2 id="numerical-integration">Numerical integration</h2>
<p>The GNU Scientific Library (GSL) is a collection of numerical algorithms written in C. In many cases it is convenient to use a C++ wrapper in stead of the C API directly. Here we define an interface around the <code>gsl_integration_qagiu</code> function, which integrates functions from a lower bound to upper infinity. The C API expects a pointer to a function and a <code>gsl_integration_workspace</code> to be provided. The function pointed to should accept a <code>double</code> and a <code>void *</code>. The latter argument can be used to pass around extra arguments of which the function knows the intended type. In our case we reinterpret the void pointer as a generic C++ <code>std::function</code> pointer and then call that. This allows any callable C++ function to be passed to <code>integrate_qagiu</code>.</p>
<p>Since we only call the integrator once, we do allocation and destruction of the <code>gsl_integration_workspace</code> in the body of <code>integrate_qagiu</code>. In a situation where <code>integrate_qagiu</code> would be called repeatedly, it is better to use a more complicated wrapper.</p>
<div class="annotated-code">
<p><span><em>«gsl-integrate-qagiu»=</em></span></p>
<div class="sourceCode" id="gsl-integrate-qagiu"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="gsl-integrate-qagiu-1"><a href="#gsl-integrate-qagiu-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;gsl/gsl_integration.h&gt;</span></span>
<span id="gsl-integrate-qagiu-2"><a href="#gsl-integrate-qagiu-2" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-3"><a href="#gsl-integrate-qagiu-3" aria-hidden="true"></a><span class="kw">using</span> Function = <span class="bu">std::</span>function&lt;<span class="dt">double</span> (<span class="dt">double</span>)&gt;;</span>
<span id="gsl-integrate-qagiu-4"><a href="#gsl-integrate-qagiu-4" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-5"><a href="#gsl-integrate-qagiu-5" aria-hidden="true"></a><span class="dt">double</span> integration_helper(<span class="dt">double</span> x, <span class="dt">void</span> *params)</span>
<span id="gsl-integrate-qagiu-6"><a href="#gsl-integrate-qagiu-6" aria-hidden="true"></a>{</span>
<span id="gsl-integrate-qagiu-7"><a href="#gsl-integrate-qagiu-7" aria-hidden="true"></a>  <span class="kw">auto</span> f = <span class="kw">reinterpret_cast</span>&lt;Function *&gt;(params);</span>
<span id="gsl-integrate-qagiu-8"><a href="#gsl-integrate-qagiu-8" aria-hidden="true"></a>  <span class="cf">return</span> (*f)(x);</span>
<span id="gsl-integrate-qagiu-9"><a href="#gsl-integrate-qagiu-9" aria-hidden="true"></a>}</span>
<span id="gsl-integrate-qagiu-10"><a href="#gsl-integrate-qagiu-10" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-11"><a href="#gsl-integrate-qagiu-11" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> F&gt;</span>
<span id="gsl-integrate-qagiu-12"><a href="#gsl-integrate-qagiu-12" aria-hidden="true"></a><span class="dt">double</span> integrate_qagiu(</span>
<span id="gsl-integrate-qagiu-13"><a href="#gsl-integrate-qagiu-13" aria-hidden="true"></a>    F <span class="at">const</span> &amp;func, <span class="dt">double</span> lower,</span>
<span id="gsl-integrate-qagiu-14"><a href="#gsl-integrate-qagiu-14" aria-hidden="true"></a>    <span class="dt">double</span> epsabs, <span class="dt">double</span> epsrel, <span class="dt">size_t</span> limit=<span class="dv">1024</span>)</span>
<span id="gsl-integrate-qagiu-15"><a href="#gsl-integrate-qagiu-15" aria-hidden="true"></a>{</span>
<span id="gsl-integrate-qagiu-16"><a href="#gsl-integrate-qagiu-16" aria-hidden="true"></a>  <span class="dt">double</span> x, abserr;</span>
<span id="gsl-integrate-qagiu-17"><a href="#gsl-integrate-qagiu-17" aria-hidden="true"></a>  Function integrant = func;</span>
<span id="gsl-integrate-qagiu-18"><a href="#gsl-integrate-qagiu-18" aria-hidden="true"></a>  gsl_integration_workspace *workspace =</span>
<span id="gsl-integrate-qagiu-19"><a href="#gsl-integrate-qagiu-19" aria-hidden="true"></a>    gsl_integration_workspace_alloc(limit);</span>
<span id="gsl-integrate-qagiu-20"><a href="#gsl-integrate-qagiu-20" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-21"><a href="#gsl-integrate-qagiu-21" aria-hidden="true"></a>  gsl_function f;</span>
<span id="gsl-integrate-qagiu-22"><a href="#gsl-integrate-qagiu-22" aria-hidden="true"></a>  f.function = &amp;integration_helper;</span>
<span id="gsl-integrate-qagiu-23"><a href="#gsl-integrate-qagiu-23" aria-hidden="true"></a>  f.params = <span class="kw">reinterpret_cast</span>&lt;<span class="dt">void</span> *&gt;(&amp;integrant);</span>
<span id="gsl-integrate-qagiu-24"><a href="#gsl-integrate-qagiu-24" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-25"><a href="#gsl-integrate-qagiu-25" aria-hidden="true"></a>  gsl_integration_qagiu(</span>
<span id="gsl-integrate-qagiu-26"><a href="#gsl-integrate-qagiu-26" aria-hidden="true"></a>    &amp;f, lower, epsabs, epsrel, limit,</span>
<span id="gsl-integrate-qagiu-27"><a href="#gsl-integrate-qagiu-27" aria-hidden="true"></a>    workspace, &amp;x, &amp;abserr);</span>
<span id="gsl-integrate-qagiu-28"><a href="#gsl-integrate-qagiu-28" aria-hidden="true"></a></span>
<span id="gsl-integrate-qagiu-29"><a href="#gsl-integrate-qagiu-29" aria-hidden="true"></a>  gsl_integration_workspace_free(workspace);</span>
<span id="gsl-integrate-qagiu-30"><a href="#gsl-integrate-qagiu-30" aria-hidden="true"></a>  <span class="cf">return</span> x;</span>
<span id="gsl-integrate-qagiu-31"><a href="#gsl-integrate-qagiu-31" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="manipulating-meshes">Manipulating meshes</h2>
<p>To visualise a structure it is important to limit the visualisation to a specific region. Otherwise the image is flooded with too many polygons and we lose the aim of visualisation: making structures visible.</p>
<p>In the <code>mesh_manipulation.hh</code> header file we define methods to cut a mesh using a spherical surface or a plane.</p>
<div class="annotated-code">
<p><span><em>«src/mesh_manipulation.hh»=</em></span></p>
<div class="sourceCode" id="cb25" data-file="src/mesh_manipulation.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;tuple&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;surface.hh&quot;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>&lt;&lt;split-polygon&gt;&gt;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>&lt;&lt;select-mesh&gt;&gt;</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>&lt;&lt;clean-mesh&gt;&gt;</span></code></pre></div>
</div>
<h3 id="surfaces">Surfaces</h3>
<p>To select parts of a mesh we need to define a surface that can tell us on what side a point lies, and if we have two points, if and where the segment between those points intersects. This concept of a <code>Surface</code> is embodied by the following abstract base class:</p>
<div class="annotated-code">
<p><span><em>«src/surface.hh»=</em></span></p>
<div class="sourceCode" id="cb26" data-file="src/surface.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>&lt;&lt;include-optional&gt;&gt;</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span class="kw">class</span> Surface</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>{</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="dt">int</span> oriented_side(Point <span class="at">const</span> &amp;p) <span class="at">const</span> = <span class="dv">0</span>;</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>  <span class="kw">virtual</span> <span class="bu">std::</span>optional&lt;Point&gt; intersect(</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>    Point <span class="at">const</span> &amp;a, Point <span class="at">const</span> &amp;b) <span class="at">const</span> = <span class="dv">0</span>;</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>  <span class="kw">virtual</span> ~Surface() {}</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h4 id="stdoptional"><code>std::optional</code></h4>
<p>We’re using a library feature of C++17, namely <code>std::optional</code>. In C++14, this is included in the <code>std::experimental</code> namespace. With this macro, we can use <code>std::optional</code> in both cases.</p>
<div class="annotated-code">
<p><span><em>«include-optional»=</em></span></p>
<div class="sourceCode" id="include-optional"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="include-optional-1"><a href="#include-optional-1" aria-hidden="true"></a><span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> == 201402L</span></span>
<span id="include-optional-2"><a href="#include-optional-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;experimental/optional&gt;</span></span>
<span id="include-optional-3"><a href="#include-optional-3" aria-hidden="true"></a><span class="kw">namespace</span> std {</span>
<span id="include-optional-4"><a href="#include-optional-4" aria-hidden="true"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>experimental;</span>
<span id="include-optional-5"><a href="#include-optional-5" aria-hidden="true"></a>}</span>
<span id="include-optional-6"><a href="#include-optional-6" aria-hidden="true"></a><span class="pp">#elif </span><span class="ot">__cplusplus</span><span class="pp"> == 201703L</span></span>
<span id="include-optional-7"><a href="#include-optional-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;optional&gt;</span></span>
<span id="include-optional-8"><a href="#include-optional-8" aria-hidden="true"></a><span class="pp">#else</span></span>
<span id="include-optional-9"><a href="#include-optional-9" aria-hidden="true"></a><span class="pp">#error &quot;Unrecognised C++ version.&quot;</span></span>
<span id="include-optional-10"><a href="#include-optional-10" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
<h3 id="split-a-polygon">Split a polygon</h3>
<p>Given an implementation of such a class, we can implement a function that will split a polygon in two parts, each on either side of the surface. This makes certain assumptions about the surface and the polygon that will not always hold, but suffice for our purposes of visualisation.</p>
<p>We still have to define the input <code>Polygon</code> type,</p>
<div class="annotated-code">
<p><span><em>«split-polygon»=</em></span></p>
<div class="sourceCode" id="split-polygon"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="split-polygon-1"><a href="#split-polygon-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="split-polygon-2"><a href="#split-polygon-2" aria-hidden="true"></a><span class="kw">using</span> Polygon = <span class="bu">std::</span>tuple&lt;</span>
<span id="split-polygon-3"><a href="#split-polygon-3" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;Point&gt; *,</span>
<span id="split-polygon-4"><a href="#split-polygon-4" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt;&gt;;</span></code></pre></div>
</div>
<p>The algorithm returns two polygons, one of which lies below the surface, the other above.</p>
<div class="annotated-code">
<p><span><em>«split-polygon»+</em></span></p>
<div class="sourceCode" id="split-polygon"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="split-polygon-1"><a href="#split-polygon-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="split-polygon-2"><a href="#split-polygon-2" aria-hidden="true"></a><span class="kw">using</span> PolygonPair = <span class="bu">std::</span>tuple&lt;</span>
<span id="split-polygon-3"><a href="#split-polygon-3" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;Point&gt; *,</span>
<span id="split-polygon-4"><a href="#split-polygon-4" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt;,</span>
<span id="split-polygon-5"><a href="#split-polygon-5" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt;&gt;;</span></code></pre></div>
</div>
<p>The third argument <code>closed</code> tells if the given path is cyclic or not. This is a distinction between having a polygon or a chain of line segments.</p>
<div class="annotated-code">
<p><span><em>«split-polygon»+</em></span></p>
<div class="sourceCode" id="split-polygon"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="split-polygon-1"><a href="#split-polygon-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="split-polygon-2"><a href="#split-polygon-2" aria-hidden="true"></a>PolygonPair&lt;Point&gt; split_polygon(</span>
<span id="split-polygon-3"><a href="#split-polygon-3" aria-hidden="true"></a>    Polygon&lt;Point&gt; <span class="at">const</span> &amp;polygon,</span>
<span id="split-polygon-4"><a href="#split-polygon-4" aria-hidden="true"></a>    Surface&lt;Point&gt; <span class="at">const</span> &amp;surface,</span>
<span id="split-polygon-5"><a href="#split-polygon-5" aria-hidden="true"></a>    <span class="dt">bool</span> closed = <span class="kw">true</span>)</span>
<span id="split-polygon-6"><a href="#split-polygon-6" aria-hidden="true"></a>{</span>
<span id="split-polygon-7"><a href="#split-polygon-7" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;Point&gt; *vertices = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(polygon);</span>
<span id="split-polygon-8"><a href="#split-polygon-8" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; orig = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(polygon), r1, r2;</span>
<span id="split-polygon-9"><a href="#split-polygon-9" aria-hidden="true"></a></span>
<span id="split-polygon-10"><a href="#split-polygon-10" aria-hidden="true"></a>  <span class="kw">auto</span> is_below = [&amp;vertices, &amp;surface] (<span class="dt">unsigned</span> i) -&gt; <span class="dt">bool</span> {</span>
<span id="split-polygon-11"><a href="#split-polygon-11" aria-hidden="true"></a>    <span class="cf">return</span> (surface.oriented_side((*vertices)[i]) == -<span class="dv">1</span>);</span>
<span id="split-polygon-12"><a href="#split-polygon-12" aria-hidden="true"></a>  };</span>
<span id="split-polygon-13"><a href="#split-polygon-13" aria-hidden="true"></a></span>
<span id="split-polygon-14"><a href="#split-polygon-14" aria-hidden="true"></a>  <span class="cf">if</span> (closed)</span>
<span id="split-polygon-15"><a href="#split-polygon-15" aria-hidden="true"></a>    orig.push_back(orig.front());</span>
<span id="split-polygon-16"><a href="#split-polygon-16" aria-hidden="true"></a>  <span class="cf">else</span></span>
<span id="split-polygon-17"><a href="#split-polygon-17" aria-hidden="true"></a>    r1.push_back(orig.front());</span>
<span id="split-polygon-18"><a href="#split-polygon-18" aria-hidden="true"></a></span>
<span id="split-polygon-19"><a href="#split-polygon-19" aria-hidden="true"></a>  <span class="kw">auto</span> i = orig.begin();</span>
<span id="split-polygon-20"><a href="#split-polygon-20" aria-hidden="true"></a>  <span class="kw">auto</span> j = i; ++j;</span>
<span id="split-polygon-21"><a href="#split-polygon-21" aria-hidden="true"></a>  <span class="dt">bool</span> below = is_below(*i);</span>
<span id="split-polygon-22"><a href="#split-polygon-22" aria-hidden="true"></a></span>
<span id="split-polygon-23"><a href="#split-polygon-23" aria-hidden="true"></a>  <span class="cf">while</span> (j != orig.end())</span>
<span id="split-polygon-24"><a href="#split-polygon-24" aria-hidden="true"></a>  {</span>
<span id="split-polygon-25"><a href="#split-polygon-25" aria-hidden="true"></a>    <span class="cf">if</span> (below != is_below(*j)) <span class="co">// surface crossed</span></span>
<span id="split-polygon-26"><a href="#split-polygon-26" aria-hidden="true"></a>    {</span>
<span id="split-polygon-27"><a href="#split-polygon-27" aria-hidden="true"></a>      <span class="cf">if</span> (<span class="kw">auto</span> q = surface.intersect(</span>
<span id="split-polygon-28"><a href="#split-polygon-28" aria-hidden="true"></a>            (*vertices)[*i], (*vertices)[*j])) {</span>
<span id="split-polygon-29"><a href="#split-polygon-29" aria-hidden="true"></a>        r1.push_back(vertices-&gt;size());</span>
<span id="split-polygon-30"><a href="#split-polygon-30" aria-hidden="true"></a>        r2.push_back(vertices-&gt;size());</span>
<span id="split-polygon-31"><a href="#split-polygon-31" aria-hidden="true"></a>        vertices-&gt;push_back(*q);</span>
<span id="split-polygon-32"><a href="#split-polygon-32" aria-hidden="true"></a>        <span class="bu">std::</span>swap(r1, r2);</span>
<span id="split-polygon-33"><a href="#split-polygon-33" aria-hidden="true"></a>      } <span class="cf">else</span> {</span>
<span id="split-polygon-34"><a href="#split-polygon-34" aria-hidden="true"></a>        <span class="cf">return</span> PolygonPair&lt;Point&gt;();</span>
<span id="split-polygon-35"><a href="#split-polygon-35" aria-hidden="true"></a>      }</span>
<span id="split-polygon-36"><a href="#split-polygon-36" aria-hidden="true"></a></span>
<span id="split-polygon-37"><a href="#split-polygon-37" aria-hidden="true"></a>      below = <span class="kw">not</span> below;</span>
<span id="split-polygon-38"><a href="#split-polygon-38" aria-hidden="true"></a>    } <span class="cf">else</span> {</span>
<span id="split-polygon-39"><a href="#split-polygon-39" aria-hidden="true"></a>      r1.push_back(*j);</span>
<span id="split-polygon-40"><a href="#split-polygon-40" aria-hidden="true"></a>      ++i; ++j;</span>
<span id="split-polygon-41"><a href="#split-polygon-41" aria-hidden="true"></a>    }</span>
<span id="split-polygon-42"><a href="#split-polygon-42" aria-hidden="true"></a>  }</span>
<span id="split-polygon-43"><a href="#split-polygon-43" aria-hidden="true"></a></span>
<span id="split-polygon-44"><a href="#split-polygon-44" aria-hidden="true"></a>  <span class="cf">if</span> (below)</span>
<span id="split-polygon-45"><a href="#split-polygon-45" aria-hidden="true"></a>    <span class="cf">return</span> PolygonPair&lt;Point&gt;(vertices, r1, r2);</span>
<span id="split-polygon-46"><a href="#split-polygon-46" aria-hidden="true"></a>  <span class="cf">else</span></span>
<span id="split-polygon-47"><a href="#split-polygon-47" aria-hidden="true"></a>    <span class="cf">return</span> PolygonPair&lt;Point&gt;(vertices, r2, r1);</span>
<span id="split-polygon-48"><a href="#split-polygon-48" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="the-sphere">The sphere</h3>
<p>Unfortunately CGAL seems to have no function to compute the intersection of a <code>Sphere</code> with a <code>Segment</code>. We’ll take the opportunity to do a bit computational geometry our selves.</p>
<div class="annotated-code">
<p><span><em>«src/sphere.hh»=</em></span></p>
<div class="sourceCode" id="cb27" data-file="src/sphere.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;surface.hh&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> K&gt;</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="kw">class</span> Sphere: <span class="kw">public</span> Surface&lt;<span class="kw">typename</span> K::Point_3&gt;</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>{</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>  <span class="kw">using</span> Point   = <span class="kw">typename</span> K::Point_3;</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>  <span class="kw">using</span> Vector  = <span class="kw">typename</span> K::Vector_3;</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>  &lt;&lt;sphere-members&gt;&gt;</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>  Sphere(Point <span class="at">const</span> &amp;p, <span class="dt">double</span> r):</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true"></a>      origin(p), radius_squared(r*r) {}</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true"></a>  &lt;&lt;sphere-oriented-side&gt;&gt;</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true"></a>  &lt;&lt;sphere-intersect&gt;&gt;</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<p>The <code>Sphere</code> data type will have two members:</p>
<div class="annotated-code">
<p><span><em>«sphere-members»=</em></span></p>
<div class="sourceCode" id="sphere-members"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="sphere-members-1"><a href="#sphere-members-1" aria-hidden="true"></a>Point  origin;</span>
<span id="sphere-members-2"><a href="#sphere-members-2" aria-hidden="true"></a><span class="dt">double</span> radius_squared;</span></code></pre></div>
</div>
<p>Now, any point will have an orientation with respect to this sphere,</p>
<p><span class="math display">\[{\rm orient}(\vec{o}, r, \vec{p}) = \begin{cases}
-1 &amp; \quad {\rm if}~(\vec{p} - \vec{o})^2 &lt; r^2\\
0 &amp; \quad {\rm if}~(\vec{p} - \vec{o})^2 = r^2\\
1 &amp; \quad {\rm if}~(\vec{p} - \vec{o})^2 &gt; r^2\\
\end{cases}\]</span></p>
<div class="annotated-code">
<p><span><em>«sphere-oriented-side»=</em></span></p>
<div class="sourceCode" id="sphere-oriented-side"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="sphere-oriented-side-1"><a href="#sphere-oriented-side-1" aria-hidden="true"></a><span class="dt">int</span> oriented_side(Point <span class="at">const</span> &amp;p) <span class="at">const</span></span>
<span id="sphere-oriented-side-2"><a href="#sphere-oriented-side-2" aria-hidden="true"></a>{</span>
<span id="sphere-oriented-side-3"><a href="#sphere-oriented-side-3" aria-hidden="true"></a>  <span class="dt">double</span> d = (p - origin).squared_length();</span>
<span id="sphere-oriented-side-4"><a href="#sphere-oriented-side-4" aria-hidden="true"></a></span>
<span id="sphere-oriented-side-5"><a href="#sphere-oriented-side-5" aria-hidden="true"></a>  <span class="cf">if</span> (d &lt; radius_squared)</span>
<span id="sphere-oriented-side-6"><a href="#sphere-oriented-side-6" aria-hidden="true"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="sphere-oriented-side-7"><a href="#sphere-oriented-side-7" aria-hidden="true"></a></span>
<span id="sphere-oriented-side-8"><a href="#sphere-oriented-side-8" aria-hidden="true"></a>  <span class="cf">if</span> (d &gt; radius_squared)</span>
<span id="sphere-oriented-side-9"><a href="#sphere-oriented-side-9" aria-hidden="true"></a>    <span class="cf">return</span> +<span class="dv">1</span>;</span>
<span id="sphere-oriented-side-10"><a href="#sphere-oriented-side-10" aria-hidden="true"></a></span>
<span id="sphere-oriented-side-11"><a href="#sphere-oriented-side-11" aria-hidden="true"></a>  <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="sphere-oriented-side-12"><a href="#sphere-oriented-side-12" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<p>Next, given a directed segment from <span class="math inline">\(\vec{a}\)</span> to <span class="math inline">\(\vec{b}\)</span>, we’d like to know if and where the segment will intersect the sphere first. This is done by solving a quadratic equation in terms of the vector going from <span class="math inline">\(\vec{a}\)</span> to <span class="math inline">\(\vec{b}\)</span>, <span class="math inline">\(\vec{m} = \vec{b} - \vec{a}\)</span>, and the vector from the origin <span class="math inline">\(\vec{o}\)</span> to <span class="math inline">\(\vec{a}\)</span>, <span class="math inline">\(\vec{n} = \vec{a} - \vec{o}\)</span>.</p>
<p>The points on the segment are given by the function <span class="math display">\[s(t) = \vec{a} + t\vec{m}.\]</span> And the sphere is defined by the equation <span class="math display">\[(\vec{x} - \vec{o})^2 = r^2.\]</span> Then the resulting equation is, <span class="math display">\[s^2 = (\vec{a} + t\vec{m} - \vec{o})^2 = n^2 + 2t \vec{n} \vec{m} + m^2 t^2,\]</span> which is solved by, <span class="math display">\[t = \vec{m}\cdot\vec{n} \pm \sqrt{m^2 (n^2 - r^2)}.\]</span></p>
<p>If the discriminant <span class="math inline">\(D = m^2 (n^2 - r^2)\)</span> is negative, there is no intersection. We reflect this by returning a <code>std::optional&lt;Point&gt;</code>. Also, we only return a point if the found solution is for <span class="math inline">\(0 \le t \le 1\)</span>.</p>
<div class="annotated-code">
<p><span><em>«sphere-intersect»=</em></span></p>
<div class="sourceCode" id="sphere-intersect"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="sphere-intersect-1"><a href="#sphere-intersect-1" aria-hidden="true"></a><span class="bu">std::</span>optional&lt;Point&gt; intersect(Point <span class="at">const</span> &amp;a, Point <span class="at">const</span> &amp;b) <span class="at">const</span></span>
<span id="sphere-intersect-2"><a href="#sphere-intersect-2" aria-hidden="true"></a>{</span>
<span id="sphere-intersect-3"><a href="#sphere-intersect-3" aria-hidden="true"></a>  <span class="cf">if</span> (oriented_side(a) * oriented_side(b) &gt;= <span class="dv">0</span>)</span>
<span id="sphere-intersect-4"><a href="#sphere-intersect-4" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>nullopt;</span>
<span id="sphere-intersect-5"><a href="#sphere-intersect-5" aria-hidden="true"></a></span>
<span id="sphere-intersect-6"><a href="#sphere-intersect-6" aria-hidden="true"></a>  Vector m = b - a, n = a - origin;</span>
<span id="sphere-intersect-7"><a href="#sphere-intersect-7" aria-hidden="true"></a>  <span class="dt">double</span> <span class="va">m_sqr</span> = m.squared_length(),</span>
<span id="sphere-intersect-8"><a href="#sphere-intersect-8" aria-hidden="true"></a>          n_sqr = n.squared_length(),</span>
<span id="sphere-intersect-9"><a href="#sphere-intersect-9" aria-hidden="true"></a>          mn    = m*n;</span>
<span id="sphere-intersect-10"><a href="#sphere-intersect-10" aria-hidden="true"></a></span>
<span id="sphere-intersect-11"><a href="#sphere-intersect-11" aria-hidden="true"></a>  <span class="dt">double</span> D = mn*mn - (<span class="va">m_sqr</span> * (n_sqr - radius_squared));</span>
<span id="sphere-intersect-12"><a href="#sphere-intersect-12" aria-hidden="true"></a></span>
<span id="sphere-intersect-13"><a href="#sphere-intersect-13" aria-hidden="true"></a>  <span class="cf">if</span> (D &lt; <span class="dv">0</span>)</span>
<span id="sphere-intersect-14"><a href="#sphere-intersect-14" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>nullopt;               <span class="co">// shouldn&#39;t happen</span></span>
<span id="sphere-intersect-15"><a href="#sphere-intersect-15" aria-hidden="true"></a></span>
<span id="sphere-intersect-16"><a href="#sphere-intersect-16" aria-hidden="true"></a>  <span class="dt">double</span> sol_m = (- mn - sqrt(D)) / <span class="va">m_sqr</span>,</span>
<span id="sphere-intersect-17"><a href="#sphere-intersect-17" aria-hidden="true"></a>         sol_p = (- mn + sqrt(D)) / <span class="va">m_sqr</span>;</span>
<span id="sphere-intersect-18"><a href="#sphere-intersect-18" aria-hidden="true"></a></span>
<span id="sphere-intersect-19"><a href="#sphere-intersect-19" aria-hidden="true"></a>  <span class="cf">if</span> ((sol_m &gt;= <span class="dv">0</span>) <span class="kw">and</span> (sol_m &lt;= <span class="fl">1.0</span>))</span>
<span id="sphere-intersect-20"><a href="#sphere-intersect-20" aria-hidden="true"></a>      <span class="cf">return</span> a + m*sol_m;</span>
<span id="sphere-intersect-21"><a href="#sphere-intersect-21" aria-hidden="true"></a></span>
<span id="sphere-intersect-22"><a href="#sphere-intersect-22" aria-hidden="true"></a>  <span class="cf">if</span> ((sol_p &gt;= <span class="dv">0</span>) <span class="kw">and</span> (sol_p &lt;= <span class="fl">1.0</span>))</span>
<span id="sphere-intersect-23"><a href="#sphere-intersect-23" aria-hidden="true"></a>      <span class="cf">return</span> a + m*sol_p;</span>
<span id="sphere-intersect-24"><a href="#sphere-intersect-24" aria-hidden="true"></a></span>
<span id="sphere-intersect-25"><a href="#sphere-intersect-25" aria-hidden="true"></a>  <span class="cf">return</span> <span class="bu">std::</span>nullopt;                 <span class="co">// shouldn&#39;t happen</span></span>
<span id="sphere-intersect-26"><a href="#sphere-intersect-26" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="plane">Plane</h3>
<p>Similar to the definition of a sphere, we’ll define a plane.</p>
<div class="annotated-code">
<p><span><em>«src/plane.hh»=</em></span></p>
<div class="sourceCode" id="cb28" data-file="src/plane.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;surface.hh&quot;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>&lt;&lt;sign-function&gt;&gt;</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> K&gt;</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a><span class="kw">class</span> Plane: <span class="kw">public</span> Surface&lt;<span class="kw">typename</span> K::Point_3&gt;</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>{</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>  <span class="kw">using</span> Point   = <span class="kw">typename</span> K::Point_3;</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>  <span class="kw">using</span> Vector  = <span class="kw">typename</span> K::Vector_3;</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>  Point  centre;</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>  Vector normal;</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a>  Plane(Point <span class="at">const</span> &amp;centre, Vector <span class="at">const</span> &amp;normal)</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true"></a>    : centre(centre)</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true"></a>    , normal(normal)</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true"></a>  {}</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true"></a>  &lt;&lt;plane-oriented-side&gt;&gt;</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true"></a>  &lt;&lt;plane-intersect&gt;&gt;</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h4 id="sign-function"><code>sign</code> function</h4>
<p>This generic function returns -1, 0 or 1 according to the sign of the given number.</p>
<div class="annotated-code">
<p><span><em>«sign-function»=</em></span></p>
<div class="sourceCode" id="sign-function"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="sign-function-1"><a href="#sign-function-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="sign-function-2"><a href="#sign-function-2" aria-hidden="true"></a><span class="kw">inline</span> <span class="dt">int</span> sign(T a) {</span>
<span id="sign-function-3"><a href="#sign-function-3" aria-hidden="true"></a>  <span class="cf">return</span> (a &lt; <span class="dv">0</span> ? -<span class="dv">1</span> : (a == <span class="dv">0</span> ? <span class="dv">0</span> : <span class="dv">1</span>));</span>
<span id="sign-function-4"><a href="#sign-function-4" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="plane-oriented-side">Plane Oriented side</h4>
<p>The oriented side of a point <span class="math inline">\({\bf a}\)</span> to a plane with normal <span class="math inline">\({\bf n}\)</span> through point <span class="math inline">\({\bf c}\)</span> is given by</p>
<p><span class="math display">\[{\rm sign}(({\bf a} - {\bf c}) \cdot {\bf n}).\]</span></p>
<p>A point on the positive side lies in the direction of the normal vector.</p>
<div class="annotated-code">
<p><span><em>«plane-oriented-side»=</em></span></p>
<div class="sourceCode" id="plane-oriented-side"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="plane-oriented-side-1"><a href="#plane-oriented-side-1" aria-hidden="true"></a><span class="dt">int</span> oriented_side(Point <span class="at">const</span> &amp;a) <span class="at">const</span> {</span>
<span id="plane-oriented-side-2"><a href="#plane-oriented-side-2" aria-hidden="true"></a>  <span class="cf">return</span> sign((a - centre) * normal);</span>
<span id="plane-oriented-side-3"><a href="#plane-oriented-side-3" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h4 id="plane-intersection">Plane Intersection</h4>
<p>Given two points <span class="math inline">\({\bf a}\)</span> and <span class="math inline">\({\bf b}\)</span>, we have a vector ${} = {} - {}, and a vector <span class="math inline">\({\bf u} = {\bf c} - {\bf a}\)</span> to the point in the plane. Then we can define a time <span class="math inline">\(t\)</span> to parametrise the line segment from <span class="math inline">\({\bf a}\)</span> at <span class="math inline">\(t = 0\)</span> to <span class="math inline">\({\bf b}\)</span> at <span class="math inline">\(t = 1\)</span>. The intersection with the plane is at</p>
<p><span class="math display">\[t = \frac{{\bf u} \cdot {\bf n}}{{\bf v} \cdot {\bf n}}.\]</span></p>
<div class="annotated-code">
<p><span><em>«plane-intersect»=</em></span></p>
<div class="sourceCode" id="plane-intersect"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="plane-intersect-1"><a href="#plane-intersect-1" aria-hidden="true"></a><span class="bu">std::</span>optional&lt;Point&gt; intersect(Point <span class="at">const</span> &amp;a, Point <span class="at">const</span> &amp;b) <span class="at">const</span></span>
<span id="plane-intersect-2"><a href="#plane-intersect-2" aria-hidden="true"></a>{</span>
<span id="plane-intersect-3"><a href="#plane-intersect-3" aria-hidden="true"></a>  Vector u = centre - a,</span>
<span id="plane-intersect-4"><a href="#plane-intersect-4" aria-hidden="true"></a>         v = b - a;</span>
<span id="plane-intersect-5"><a href="#plane-intersect-5" aria-hidden="true"></a></span>
<span id="plane-intersect-6"><a href="#plane-intersect-6" aria-hidden="true"></a>  <span class="cf">if</span> (v * normal == <span class="dv">0</span>)</span>
<span id="plane-intersect-7"><a href="#plane-intersect-7" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>nullopt;</span>
<span id="plane-intersect-8"><a href="#plane-intersect-8" aria-hidden="true"></a></span>
<span id="plane-intersect-9"><a href="#plane-intersect-9" aria-hidden="true"></a>  <span class="dt">double</span> t = (u * normal) / (v * normal);</span>
<span id="plane-intersect-10"><a href="#plane-intersect-10" aria-hidden="true"></a></span>
<span id="plane-intersect-11"><a href="#plane-intersect-11" aria-hidden="true"></a>  <span class="cf">if</span> (t &lt; <span class="dv">0</span> || t &gt; <span class="dv">1</span>)</span>
<span id="plane-intersect-12"><a href="#plane-intersect-12" aria-hidden="true"></a>    <span class="cf">return</span> <span class="bu">std::</span>nullopt;</span>
<span id="plane-intersect-13"><a href="#plane-intersect-13" aria-hidden="true"></a></span>
<span id="plane-intersect-14"><a href="#plane-intersect-14" aria-hidden="true"></a>  <span class="cf">return</span> a + t * v;</span>
<span id="plane-intersect-15"><a href="#plane-intersect-15" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="clean-mesh">Clean mesh</h3>
<p>Once we have selected a part of the mesh by cutting polygons, the mesh contains a lot of vertices that have no associated polygon. These vertices need to be removed. This also means that the vertex indices contained in the logical polygon data need to be remapped. The <code>clean</code> function takes a <code>Mesh</code>, only copies the vertices that are referenced in the polygons and remaps the polygons, creating a new <code>Mesh</code> instance.</p>
<div class="annotated-code">
<p><span><em>«clean-mesh»=</em></span></p>
<div class="sourceCode" id="clean-mesh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="clean-mesh-1"><a href="#clean-mesh-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point, <span class="kw">typename</span> Info&gt;</span>
<span id="clean-mesh-2"><a href="#clean-mesh-2" aria-hidden="true"></a>Mesh&lt;Point, Info&gt; clean(</span>
<span id="clean-mesh-3"><a href="#clean-mesh-3" aria-hidden="true"></a>    Mesh&lt;Point, Info&gt; <span class="at">const</span> &amp;source)</span>
<span id="clean-mesh-4"><a href="#clean-mesh-4" aria-hidden="true"></a>{</span>
<span id="clean-mesh-5"><a href="#clean-mesh-5" aria-hidden="true"></a>  Mesh&lt;Point, Info&gt; result;</span>
<span id="clean-mesh-6"><a href="#clean-mesh-6" aria-hidden="true"></a>  <span class="bu">std::</span>map&lt;<span class="dt">unsigned</span>, <span class="dt">unsigned</span>&gt; vertex_map;</span>
<span id="clean-mesh-7"><a href="#clean-mesh-7" aria-hidden="true"></a></span>
<span id="clean-mesh-8"><a href="#clean-mesh-8" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> i : source.data) {</span>
<span id="clean-mesh-9"><a href="#clean-mesh-9" aria-hidden="true"></a>    <span class="cf">if</span> (vertex_map.count(i) == <span class="dv">0</span>) {</span>
<span id="clean-mesh-10"><a href="#clean-mesh-10" aria-hidden="true"></a>      vertex_map[i] = result.vertices.size();</span>
<span id="clean-mesh-11"><a href="#clean-mesh-11" aria-hidden="true"></a>      result.vertices.push_back(source.vertices[i]);</span>
<span id="clean-mesh-12"><a href="#clean-mesh-12" aria-hidden="true"></a>    }</span>
<span id="clean-mesh-13"><a href="#clean-mesh-13" aria-hidden="true"></a></span>
<span id="clean-mesh-14"><a href="#clean-mesh-14" aria-hidden="true"></a>    result.data.push_back(vertex_map[i]);</span>
<span id="clean-mesh-15"><a href="#clean-mesh-15" aria-hidden="true"></a>  }</span>
<span id="clean-mesh-16"><a href="#clean-mesh-16" aria-hidden="true"></a></span>
<span id="clean-mesh-17"><a href="#clean-mesh-17" aria-hidden="true"></a>  result.info = source.info;</span>
<span id="clean-mesh-18"><a href="#clean-mesh-18" aria-hidden="true"></a>  result.sizes = source.sizes;</span>
<span id="clean-mesh-19"><a href="#clean-mesh-19" aria-hidden="true"></a>  <span class="cf">return</span> result;</span>
<span id="clean-mesh-20"><a href="#clean-mesh-20" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="select-a-mesh">Select a mesh</h3>
<div class="annotated-code">
<p><span><em>«select-mesh»=</em></span></p>
<div class="sourceCode" id="select-mesh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="select-mesh-1"><a href="#select-mesh-1" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point, <span class="kw">typename</span> Info&gt;</span>
<span id="select-mesh-2"><a href="#select-mesh-2" aria-hidden="true"></a>Mesh&lt;Point, Info&gt; select_mesh(</span>
<span id="select-mesh-3"><a href="#select-mesh-3" aria-hidden="true"></a>    Mesh&lt;Point, Info&gt; <span class="at">const</span> &amp;mesh,</span>
<span id="select-mesh-4"><a href="#select-mesh-4" aria-hidden="true"></a>    Surface&lt;Point&gt; <span class="at">const</span> &amp;surface,</span>
<span id="select-mesh-5"><a href="#select-mesh-5" aria-hidden="true"></a>    <span class="dt">bool</span> closed=<span class="kw">true</span>)</span>
<span id="select-mesh-6"><a href="#select-mesh-6" aria-hidden="true"></a>{</span>
<span id="select-mesh-7"><a href="#select-mesh-7" aria-hidden="true"></a>  Mesh&lt;Point, Info&gt; result;</span>
<span id="select-mesh-8"><a href="#select-mesh-8" aria-hidden="true"></a>  result.vertices = mesh.vertices;</span>
<span id="select-mesh-9"><a href="#select-mesh-9" aria-hidden="true"></a></span>
<span id="select-mesh-10"><a href="#select-mesh-10" aria-hidden="true"></a>  <span class="dt">unsigned</span> i = <span class="dv">0</span>, j = <span class="dv">0</span>;</span>
<span id="select-mesh-11"><a href="#select-mesh-11" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> s : mesh.sizes)</span>
<span id="select-mesh-12"><a href="#select-mesh-12" aria-hidden="true"></a>  {</span>
<span id="select-mesh-13"><a href="#select-mesh-13" aria-hidden="true"></a>    <span class="kw">auto</span> x = mesh.data.begin() + j;</span>
<span id="select-mesh-14"><a href="#select-mesh-14" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="dt">unsigned</span>&gt; vs(x, x + s);</span>
<span id="select-mesh-15"><a href="#select-mesh-15" aria-hidden="true"></a></span>
<span id="select-mesh-16"><a href="#select-mesh-16" aria-hidden="true"></a>    <span class="kw">auto</span> below = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(split_polygon(</span>
<span id="select-mesh-17"><a href="#select-mesh-17" aria-hidden="true"></a>      Polygon&lt;Point&gt;(&amp;result.vertices, vs),</span>
<span id="select-mesh-18"><a href="#select-mesh-18" aria-hidden="true"></a>      surface, closed));</span>
<span id="select-mesh-19"><a href="#select-mesh-19" aria-hidden="true"></a></span>
<span id="select-mesh-20"><a href="#select-mesh-20" aria-hidden="true"></a>    <span class="cf">if</span> (below.size() &gt; <span class="dv">0</span>) {</span>
<span id="select-mesh-21"><a href="#select-mesh-21" aria-hidden="true"></a>      result.push_back(below, mesh.info[i]);</span>
<span id="select-mesh-22"><a href="#select-mesh-22" aria-hidden="true"></a>    }</span>
<span id="select-mesh-23"><a href="#select-mesh-23" aria-hidden="true"></a></span>
<span id="select-mesh-24"><a href="#select-mesh-24" aria-hidden="true"></a>    ++i;</span>
<span id="select-mesh-25"><a href="#select-mesh-25" aria-hidden="true"></a>    j += s;</span>
<span id="select-mesh-26"><a href="#select-mesh-26" aria-hidden="true"></a>  }</span>
<span id="select-mesh-27"><a href="#select-mesh-27" aria-hidden="true"></a></span>
<span id="select-mesh-28"><a href="#select-mesh-28" aria-hidden="true"></a>  <span class="cf">return</span> clean(result);</span>
<span id="select-mesh-29"><a href="#select-mesh-29" aria-hidden="true"></a>}</span>
<span id="select-mesh-30"><a href="#select-mesh-30" aria-hidden="true"></a></span>
<span id="select-mesh-31"><a href="#select-mesh-31" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point, <span class="kw">typename</span> Info&gt;</span>
<span id="select-mesh-32"><a href="#select-mesh-32" aria-hidden="true"></a>Mesh&lt;Point, Info&gt; select_mesh(</span>
<span id="select-mesh-33"><a href="#select-mesh-33" aria-hidden="true"></a>    Mesh&lt;Point, Info&gt; <span class="at">const</span> &amp;mesh,</span>
<span id="select-mesh-34"><a href="#select-mesh-34" aria-hidden="true"></a>    <span class="bu">std::</span>vector&lt;<span class="bu">std::</span>unique_ptr&lt;Surface&lt;Point&gt;&gt;&gt; <span class="at">const</span> &amp;surfaces,</span>
<span id="select-mesh-35"><a href="#select-mesh-35" aria-hidden="true"></a>    <span class="dt">bool</span> closed=<span class="kw">true</span>)</span>
<span id="select-mesh-36"><a href="#select-mesh-36" aria-hidden="true"></a>{</span>
<span id="select-mesh-37"><a href="#select-mesh-37" aria-hidden="true"></a>  Mesh&lt;Point, Info&gt; m = mesh;</span>
<span id="select-mesh-38"><a href="#select-mesh-38" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span> &amp;s : surfaces)</span>
<span id="select-mesh-39"><a href="#select-mesh-39" aria-hidden="true"></a>    m = select_mesh(m, *s, closed);</span>
<span id="select-mesh-40"><a href="#select-mesh-40" aria-hidden="true"></a>  <span class="cf">return</span> m;</span>
<span id="select-mesh-41"><a href="#select-mesh-41" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="writing-to-disk">Writing to disk</h2>
<p>For reading and writing HDF5, there is a C++ interface available. This interface is still too low level for our purposes.</p>
<h3 id="interface">Interface</h3>
<div class="annotated-code">
<p><span><em>«src/writers.hh»=</em></span></p>
<div class="sourceCode" id="cb29" data-file="src/writers.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;cgal_base.hh&quot;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;H5Cpp.h&gt;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>&lt;&lt;hdf5-file-<span class="kw">or</span>-group&gt;&gt;</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a><span class="kw">struct</span> H5TypeFactory {};</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a><span class="kw">template</span> &lt;&gt;</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a><span class="kw">struct</span> H5TypeFactory&lt;<span class="dt">double</span>&gt;</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>{</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true"></a>  <span class="at">static</span> H5::FloatType get()</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true"></a>  {</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true"></a>    <span class="cf">return</span> H5::FloatType(H5::PredType::NATIVE_DOUBLE);</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true"></a>  }</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true"></a>};</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true"></a></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true"></a><span class="kw">template</span> &lt;&gt;</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true"></a><span class="kw">struct</span> H5TypeFactory&lt;<span class="dt">unsigned</span>&gt;</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true"></a>{</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true"></a>  <span class="at">static</span> H5::IntType get()</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true"></a>  {</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true"></a>    <span class="cf">return</span> H5::IntType(H5::PredType::NATIVE_UINT);</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true"></a>  }</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true"></a>};</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true"></a></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;writers/h5_node_type.ih&quot;</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true"></a></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> V, <span class="kw">typename</span> S&gt;</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true"></a><span class="dt">void</span> write_vector_with_shape(</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true"></a>    FileOrGroup &amp;group,</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="at">const</span> &amp;name,</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true"></a>    V <span class="at">const</span> &amp;v,</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true"></a>    S <span class="at">const</span> &amp;shape)</span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true"></a>{</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">hsize_t</span>&gt; hshape(shape.begin(), shape.end());</span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true"></a>  <span class="kw">auto</span>          <span class="dt">data_type</span> = H5TypeFactory&lt;<span class="kw">typename</span> V::<span class="dt">value_type</span>&gt;::get();</span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true"></a>  H5::DataSpace data_space(hshape.size(), hshape.data());</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true"></a>  <span class="kw">auto</span>          data_set = group.createDataSet(name, <span class="dt">data_type</span>, data_space);</span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true"></a>  data_set.write(v.data(), <span class="dt">data_type</span>);</span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true"></a>}</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true"></a></span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> V&gt;</span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true"></a><span class="dt">void</span> write_vector(</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true"></a>    FileOrGroup &amp;group,</span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="at">const</span> &amp;name,</span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true"></a>    V <span class="at">const</span> &amp;v)</span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true"></a>{</span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">hsize_t</span>&gt; shape { v.size() };</span>
<span id="cb29-53"><a href="#cb29-53" aria-hidden="true"></a>  write_vector_with_shape(group, name, v, shape);</span>
<span id="cb29-54"><a href="#cb29-54" aria-hidden="true"></a>}</span>
<span id="cb29-55"><a href="#cb29-55" aria-hidden="true"></a></span>
<span id="cb29-56"><a href="#cb29-56" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Group, <span class="kw">typename</span> T&gt;</span>
<span id="cb29-57"><a href="#cb29-57" aria-hidden="true"></a><span class="dt">void</span> write_attribute(</span>
<span id="cb29-58"><a href="#cb29-58" aria-hidden="true"></a>    Group &amp;group,</span>
<span id="cb29-59"><a href="#cb29-59" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="at">const</span> &amp;name,</span>
<span id="cb29-60"><a href="#cb29-60" aria-hidden="true"></a>    T <span class="at">const</span> &amp;value)</span>
<span id="cb29-61"><a href="#cb29-61" aria-hidden="true"></a>{</span>
<span id="cb29-62"><a href="#cb29-62" aria-hidden="true"></a>  <span class="kw">auto</span> attr = group.createAttribute(</span>
<span id="cb29-63"><a href="#cb29-63" aria-hidden="true"></a>    name, H5TypeFactory&lt;T&gt;::get(), H5::DataSpace());</span>
<span id="cb29-64"><a href="#cb29-64" aria-hidden="true"></a>  attr.write(H5TypeFactory&lt;T&gt;::get(), &amp;value);</span>
<span id="cb29-65"><a href="#cb29-65" aria-hidden="true"></a>}</span>
<span id="cb29-66"><a href="#cb29-66" aria-hidden="true"></a></span>
<span id="cb29-67"><a href="#cb29-67" aria-hidden="true"></a><span class="at">extern</span> <span class="dt">void</span> write_mesh(</span>
<span id="cb29-68"><a href="#cb29-68" aria-hidden="true"></a>    FileOrGroup &amp;group,</span>
<span id="cb29-69"><a href="#cb29-69" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="at">const</span> &amp;name,</span>
<span id="cb29-70"><a href="#cb29-70" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh);</span></code></pre></div>
</div>
<p>There has been a very recent change in the API of HDF5. So we define a proxy type that is common to <code>H5::Group</code> and <code>H5::H5File</code>.</p>
<div class="annotated-code">
<p><span><em>«hdf5-file-or-group»=</em></span></p>
<div class="sourceCode" id="hdf5-file-or-group"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="hdf5-file-or-group-1"><a href="#hdf5-file-or-group-1" aria-hidden="true"></a><span class="pp">#if H5_VERSION_GE(1, 10, 1)</span></span>
<span id="hdf5-file-or-group-2"><a href="#hdf5-file-or-group-2" aria-hidden="true"></a><span class="kw">using</span> FileOrGroup = H5::Group;</span>
<span id="hdf5-file-or-group-3"><a href="#hdf5-file-or-group-3" aria-hidden="true"></a><span class="pp">#else</span></span>
<span id="hdf5-file-or-group-4"><a href="#hdf5-file-or-group-4" aria-hidden="true"></a><span class="kw">using</span> FileOrGroup = H5::CommonFG;</span>
<span id="hdf5-file-or-group-5"><a href="#hdf5-file-or-group-5" aria-hidden="true"></a><span class="pp">#endif</span></span></code></pre></div>
</div>
<h3 id="saving-to-hdf5">Saving to HDF5</h3>
<div class="annotated-code">
<p><span><em>«src/writers/h5_node_type.ih»=</em></span></p>
<div class="sourceCode" id="cb30" data-file="src/writers/h5_node_type.ih"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="at">extern</span> H5::CompType <span class="dt">h5_node_type</span>();</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="kw">template</span> &lt;&gt;</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span class="kw">struct</span> H5TypeFactory&lt;Adhesion::Node&gt;</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>{</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>  <span class="at">static</span> H5::CompType get()</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>  {</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>    <span class="cf">return</span> <span class="dt">h5_node_type</span>();</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>  }</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<div class="annotated-code">
<p><span><em>«src/writers/h5_node_type.cc»=</em></span></p>
<div class="sourceCode" id="cb31" data-file="src/writers/h5_node_type.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;adhesion.hh&quot;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;writers.hh&quot;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;cstddef&gt;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>H5::CompType <span class="dt">h5_node_type</span>()</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>{</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>  <span class="dt">hsize_t</span> dim = <span class="dv">3</span>;</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>  H5::FloatType ft(H5::PredType::NATIVE_DOUBLE);</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>  H5::IntType   it(H5::PredType::NATIVE_UINT32);</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a>  H5::ArrayType at(ft, <span class="dv">1</span>, &amp;dim);</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>  H5::CompType  ct(<span class="kw">sizeof</span>(Adhesion::Node));</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a>  ct.insertMember(<span class="st">&quot;position&quot;</span>,  <span class="dv">0</span>, at);</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a>  ct.insertMember(<span class="st">&quot;velocity&quot;</span>,  offsetof(Adhesion::Node, velocity), at);</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true"></a>  ct.insertMember(<span class="st">&quot;mass&quot;</span>,      offsetof(Adhesion::Node, mass), ft);</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true"></a>  ct.insertMember(<span class="st">&quot;node_type&quot;</span>, offsetof(Adhesion::Node, <span class="dt">node_type</span>), it);</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true"></a>  <span class="cf">return</span> ct;</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="writing-meshes-to-hdf5">Writing meshes to HDF5</h3>
<div class="annotated-code">
<p><span><em>«src/writers/hdf5-mesh.cc»=</em></span></p>
<div class="sourceCode" id="cb32" data-file="src/writers/hdf5-mesh.cc"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;writers.hh&quot;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span class="dt">void</span> write_mesh(</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    FileOrGroup &amp;file,</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    <span class="bu">std::</span>string <span class="at">const</span> &amp;name,</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>{</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>  <span class="kw">auto</span> group = file.createGroup(name);</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>&gt; vertex_data;</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true"></a>  <span class="cf">for</span> (Point <span class="at">const</span> &amp;v : mesh.vertices) {</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true"></a>    vertex_data.push_back(v[<span class="dv">0</span>]);</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true"></a>    vertex_data.push_back(v[<span class="dv">1</span>]);</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true"></a>    vertex_data.push_back(v[<span class="dv">2</span>]);</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true"></a>  }</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">hsize_t</span>&gt; vertex_shape { mesh.vertices.size(), <span class="dv">3</span> };</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true"></a>  write_vector_with_shape(group, <span class="st">&quot;vertices&quot;</span>, vertex_data, vertex_shape);</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true"></a>  write_vector(group, <span class="st">&quot;info&quot;</span>,  mesh.info);</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true"></a>  write_vector(group, <span class="st">&quot;sizes&quot;</span>, mesh.sizes);</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true"></a>  write_vector(group, <span class="st">&quot;data&quot;</span>,  mesh.data);</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h3 id="obj-file-format">Writing an OBJ file</h3>
<div class="annotated-code">
<p><span><em>«src/write_obj.hh»=</em></span></p>
<div class="sourceCode" id="cb33" data-file="src/write_obj.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;mesh.hh&quot;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="dt">void</span> write_to_obj(</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>    <span class="bu">std::</span>ostream &amp;out, <span class="bu">std::</span>string <span class="at">const</span> &amp;pre,</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>{</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>  <span class="cf">for</span> (Point <span class="at">const</span> &amp;p : mesh.vertices) {</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a>    out &lt;&lt; <span class="st">&quot;v &quot;</span> &lt;&lt; p &lt;&lt; <span class="st">&quot; 1.0</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>  }</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>  out &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">double</span> a : mesh.info) {</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>    out &lt;&lt; <span class="st">&quot;vt &quot;</span> &lt;&lt; a &lt;&lt; <span class="st">&quot; 0</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true"></a>  }</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true"></a>  out &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true"></a></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true"></a>  <span class="dt">unsigned</span> i = <span class="dv">1</span>, j = <span class="dv">0</span>;</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true"></a>  <span class="cf">for</span> (<span class="dt">unsigned</span> s : mesh.sizes) {</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true"></a>    out &lt;&lt; pre;</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="dt">unsigned</span> k = <span class="dv">0</span>; k &lt; s; ++k) {</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true"></a>      out &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; mesh.data[j] + <span class="dv">1</span> &lt;&lt; <span class="st">&quot;/&quot;</span> &lt;&lt; i;</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true"></a>      ++j;</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true"></a>    }</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true"></a>    out &lt;&lt; <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true"></a>    ++i;</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true"></a>  }</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true"></a>}</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true"></a></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true"></a><span class="dt">void</span> write_edges_to_obj(</span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true"></a>    <span class="bu">std::</span>ostream &amp;out,</span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true"></a>    Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh)</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true"></a>{</span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true"></a>  write_to_obj(out, <span class="st">&quot;l&quot;</span>, mesh);</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true"></a>}</span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true"></a></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> Point&gt;</span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true"></a><span class="dt">void</span> write_faces_to_obj(<span class="bu">std::</span>ostream &amp;out, Mesh&lt;Point, <span class="dt">double</span>&gt; <span class="at">const</span> &amp;mesh)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true"></a>{</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true"></a>  write_to_obj(out, <span class="st">&quot;f&quot;</span>, mesh);</span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true"></a>}</span></code></pre></div>
</div>
<h2 id="fourier-interface">Fourier interface</h2>
<div class="annotated-code">
<p><span><em>«src/fft.hh»=</em></span></p>
<div class="sourceCode" id="cb34" data-file="src/fft.hh"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="pp">#pragma once</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;fftw3.h&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;complex&gt;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&quot;boxparam.hh&quot;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a><span class="kw">class</span> FFTW_allocator: <span class="kw">public</span> <span class="bu">std::</span>allocator&lt;T&gt;</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>{</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>  <span class="kw">typedef</span> T           <span class="dt">value_type</span>;</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>  <span class="kw">typedef</span> T *         pointer;</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a>  <span class="kw">typedef</span> T &amp;         reference;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a>  <span class="kw">typedef</span> T <span class="at">const</span> *   const_pointer;</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a>  <span class="kw">typedef</span> T <span class="at">const</span> &amp;   const_reference;</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a>  <span class="kw">typedef</span> <span class="dt">size_t</span>      <span class="dt">size_type</span>;</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a>  <span class="kw">typedef</span> <span class="dt">ptrdiff_t</span>   <span class="dt">difference_type</span>;</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>  pointer allocate(</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>      <span class="dt">size_t</span> n,</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a>      <span class="bu">std::</span>allocator&lt;<span class="dt">void</span>&gt;::const_pointer hint = <span class="dv">0</span>)</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a>  {</span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a>    <span class="cf">return</span> <span class="kw">reinterpret_cast</span>&lt;T *&gt;(fftw_malloc(n * <span class="kw">sizeof</span>(T)));</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a>  }</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a>  <span class="dt">void</span> deallocate(</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>      pointer p,</span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true"></a>      <span class="dt">size_t</span> n)</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true"></a>  {</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true"></a>    fftw_free(p);</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true"></a>  }</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true"></a>};</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true"></a></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true"></a><span class="kw">class</span> RFFT3</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true"></a>{</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true"></a>  <span class="kw">using</span> c64 = <span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt;;</span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;c64, FFTW_allocator&lt;c64&gt;&gt;</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true"></a>    fourier_space;</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true"></a>  <span class="bu">std::</span>vector&lt;<span class="dt">double</span>, FFTW_allocator&lt;<span class="dt">double</span>&gt;&gt;</span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true"></a>    real_space;</span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true"></a></span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true"></a><span class="kw">private</span>:</span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true"></a>  BoxParam    box;</span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true"></a>  fftw_plan   d_plan_fwd, d_plan_bwd;</span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true"></a></span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true"></a><span class="kw">public</span>:</span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true"></a>  RFFT3(BoxParam <span class="at">const</span> &amp;<span class="va">box_</span>):</span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true"></a>    fourier_space(<span class="va">box_</span>.rfft_size()),</span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true"></a>    real_space(<span class="va">box_</span>.size()),</span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true"></a>    box(<span class="va">box_</span>)</span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true"></a>  {</span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true"></a>    <span class="dt">int</span> N = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(box.N);</span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true"></a></span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true"></a>    d_plan_fwd = fftw_plan_dft_r2c_3d(N, N, N,</span>
<span id="cb34-59"><a href="#cb34-59" aria-hidden="true"></a>      <span class="kw">reinterpret_cast</span>&lt;<span class="dt">double</span> *&gt;(real_space.data()),</span>
<span id="cb34-60"><a href="#cb34-60" aria-hidden="true"></a>      <span class="kw">reinterpret_cast</span>&lt;fftw_complex *&gt;(fourier_space.data()),</span>
<span id="cb34-61"><a href="#cb34-61" aria-hidden="true"></a>      FFTW_ESTIMATE);</span>
<span id="cb34-62"><a href="#cb34-62" aria-hidden="true"></a></span>
<span id="cb34-63"><a href="#cb34-63" aria-hidden="true"></a>    d_plan_bwd = fftw_plan_dft_c2r_3d(N, N, N,</span>
<span id="cb34-64"><a href="#cb34-64" aria-hidden="true"></a>      <span class="kw">reinterpret_cast</span>&lt;fftw_complex *&gt;(fourier_space.data()),</span>
<span id="cb34-65"><a href="#cb34-65" aria-hidden="true"></a>      <span class="kw">reinterpret_cast</span>&lt;<span class="dt">double</span> *&gt;(real_space.data()),</span>
<span id="cb34-66"><a href="#cb34-66" aria-hidden="true"></a>      FFTW_ESTIMATE);</span>
<span id="cb34-67"><a href="#cb34-67" aria-hidden="true"></a>  }</span>
<span id="cb34-68"><a href="#cb34-68" aria-hidden="true"></a></span>
<span id="cb34-69"><a href="#cb34-69" aria-hidden="true"></a>  <span class="dt">void</span> forward_transform()</span>
<span id="cb34-70"><a href="#cb34-70" aria-hidden="true"></a>  {</span>
<span id="cb34-71"><a href="#cb34-71" aria-hidden="true"></a>      fftw_execute(d_plan_fwd);</span>
<span id="cb34-72"><a href="#cb34-72" aria-hidden="true"></a>  }</span>
<span id="cb34-73"><a href="#cb34-73" aria-hidden="true"></a></span>
<span id="cb34-74"><a href="#cb34-74" aria-hidden="true"></a>  <span class="dt">void</span> backward_transform()</span>
<span id="cb34-75"><a href="#cb34-75" aria-hidden="true"></a>  {</span>
<span id="cb34-76"><a href="#cb34-76" aria-hidden="true"></a>      fftw_execute(d_plan_bwd);</span>
<span id="cb34-77"><a href="#cb34-77" aria-hidden="true"></a>      <span class="cf">for</span> (<span class="dt">double</span> &amp;z : real_space) z /= box.size();</span>
<span id="cb34-78"><a href="#cb34-78" aria-hidden="true"></a>  }</span>
<span id="cb34-79"><a href="#cb34-79" aria-hidden="true"></a>};</span></code></pre></div>
</div>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-Arnold1982">
<p>Arnold, V. I., S. F. Shandarin, and Ya. B. Zeldovich. 1982. “The large scale structure of the universe. I - General properties One- and two-dimensional models.” <em>Geophysical and Astrophysical Fluid Dynamics</em> 20: 111–30. <a href="https://doi.org/10.1080/03091928208209001">https://doi.org/10.1080/03091928208209001</a>.</p>
</div>
<div id="ref-Eisenstein1999">
<p>Eisenstein, D. J., and W. Hu. 1999. “Power Spectra for Cold Dark Matter and Its Variants” 511 (January): 5–15. <a href="https://doi.org/10.1086/306640">https://doi.org/10.1086/306640</a>.</p>
</div>
<div id="ref-HDF5">
<p>Folk, Mike, Gerd Heber, Quincey Koziol, Elena Pourmal, and Dana Robinson. 2011. “An Overview of the Hdf5 Technology Suite and Its Applications.” In <em>Proceedings of the Edbt/Icdt 2011 Workshop on Array Databases</em>, 36–47. ACM.</p>
</div>
<div id="ref-FFTW3">
<p>Frigo, Matteo, and Steven G. Johnson. 2005. “The Design and Implementation of FFTW3.” <em>Proceedings of the IEEE</em> 93 (2): 216–31.</p>
</div>
<div id="ref-Frisch2001">
<p>Frisch, and Bec. 2001. “Burgulence.” <em>arXiv</em> nlin: 0012033v2.</p>
</div>
<div id="ref-Galassi2002">
<p>Galassi, Mark, Jim Davies, James Theiler, Brian Gough, Gerard Jungman, Patrick Alken, Michael Booth, and Fabrice Rossi. 2002. “GNU Scientific Library.” <em>Network Theory Ltd</em> 3.</p>
</div>
<div id="ref-Hidding2018">
<p>Hidding, Johan, Rien Van de Weygaert, Mark Neyrinck, and Gert Vegter. 2018. “The Adhesion Model – the Dual Geometry of the Cosmic Web” to be subm. (-): –.</p>
</div>
<div id="ref-Hidding2014">
<p>Hidding, J., S. F. Shandarin, and R. Van de Weygaert. 2014. “The Zel’dovich approximation: key to understanding cosmic web complexity” 437 (February): 3442–72. <a href="https://doi.org/10.1093/mnras/stt2142">https://doi.org/10.1093/mnras/stt2142</a>.</p>
</div>
<div id="ref-Hopf1950">
<p>Hopf, Eberhard. 1950. “The Partial Differential Equation <span class="math inline">\(u_t + uu_x = \mu_{xx}\)</span>.” <em>Communications on Pure and Applied Mathematics</em> Vol. 3, No. 3: 201–30. <a href="https://doi.org/10.1002/cpa.3160030302">https://doi.org/10.1002/cpa.3160030302</a>.</p>
</div>
<div id="ref-cgal:pt-tds3-18b">
<p>Jamin, Clément, Sylvain Pion, and Monique Teillaud. 2018a. “3D Triangulation Data Structure.” In <em>CGAL User and Reference Manual</em>, 4.13 ed. CGAL Editorial Board. <a href="https://doc.cgal.org/4.13/Manual/packages.html#PkgTDS3Summary">https://doc.cgal.org/4.13/Manual/packages.html#PkgTDS3Summary</a>.</p>
</div>
<div id="ref-cgal:pt-t3-18b">
<p>———. 2018b. “3D Triangulations.” In <em>CGAL User and Reference Manual</em>, 4.13 ed. CGAL Editorial Board. <a href="https://doc.cgal.org/4.13/Manual/packages.html#PkgTriangulation3Summary">https://doc.cgal.org/4.13/Manual/packages.html#PkgTriangulation3Summary</a>.</p>
</div>
<div id="ref-Knuth1984">
<p>Knuth, Donald Ervin. 1984. “Literate Programming.” <em>The Computer Journal</em> 27 (2): 97–111.</p>
</div>
<div id="ref-Planck2018">
<p>Planck Collaboration, N. Aghanim, Y. Akrami, M. Ashdown, J. Aumont, C. Baccigalupi, M. Ballardini, et al. 2018. “Planck 2018 results. VI. Cosmological parameters.” <em>ArXiv E-Prints</em>, July. <a href="http://arxiv.org/abs/1807.06209">http://arxiv.org/abs/1807.06209</a>.</p>
</div>
<div id="ref-Ramsey1994">
<p>Ramsey, Norman. 1994. “Literate Programming Simplified.” <em>IEEE Software</em> 11 (5): 97–105.</p>
</div>
<div id="ref-Shandarin1989">
<p>Shandarin, S. F., and Ya. B. Zeldovich. 1989. “The large-scale structure of the universe: Turbulence, intermittency, structures in a self-gravitating medium.” <em>Reviews of Modern Physics</em> 61 (April): 185–220. <a href="https://doi.org/10.1103/RevModPhys.61.185">https://doi.org/10.1103/RevModPhys.61.185</a>.</p>
</div>
<div id="ref-Sirko2005">
<p>Sirko, Edwin. 2005. “Initial Conditions to Cosmological N-Body Simulations, or, How to Run an Ensemble of Simulations.” <em>The Astrophysical Journal</em> 634 (2): 728. <a href="http://stacks.iop.org/0004-637X/634/i=2/a=728">http://stacks.iop.org/0004-637X/634/i=2/a=728</a>.</p>
</div>
<div id="ref-cgal:eb-18b">
<p>The CGAL Project. 2018. <em>CGAL User and Reference Manual</em>. 4.13 ed. CGAL Editorial Board. <a href="https://doc.cgal.org/4.13/Manual/packages.html">https://doc.cgal.org/4.13/Manual/packages.html</a>.</p>
</div>
<div id="ref-Zeldovich1970">
<p>Zeldovich, Ya. B. 1970. “Gravitational instability: An approximate theory for large density perturbations.” 5 (March): 84–89.</p>
</div>
</div>
</div></main>



<!-- Bootstrap 4.5.0 -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

<!-- Mathjax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>
